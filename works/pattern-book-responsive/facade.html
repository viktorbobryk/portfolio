<!DOCTYPE html>
<html>
	<head>
	<meta charset="utf-8" />
	<meta name="description" content="Object-Oriented Software" />
	<meta name="keywords" content="Design, Patterns, Elements, Reusable, Object-Oriented, Software" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Facade Page</title>
	<link rel="stylesheet" href="css/reset.css" />
	<link rel="stylesheet" href="css/style.css" />
	</head>
<body>
	<span class="layout-indicator"></span>
	<header class="header-menu">
		<div class="top-wrap">
			<div class="container">
				<nav>
					<ul>
						<li><a href="adapter.html">Паттерн Adapter</a></li>
						<li><a href="bridge.html">Паттерн Bridge</a></li>
						<li><a href="composite.html">Паттерн Composite</a></li>
						<li><a href="decorator.html">Паттерн Decorator</a></li> 
						<li><a href="facade.html" class="active">Паттерн Facade</a></li><!-- !!! link MUST have .active class on corresponding page !!! -->
						<li><a href="flyweight.html">Паттерн Flyweight</a></li>
						<li><a href="proxy.html">Паттерн Proxy</a></li>
					</ul>
				</nav>
			</div>
		</div>
		<span class="arrow-down arrow-menu">&nbsp;</span>
	</header>
	<main>
		<section id="promo" class="promo-section fasade-promo">
			<div class="overlay"></div>
				<div class="container">
					<div class="titles-wrapper">
						<h1>Паттерн Facade</h1>						
				 </div>
			</div>
		</section>		
		<section class="content-section">
			<div class="container">				
				<h3>Название и классификация паттерна</h3>
				<p>Фасад - паттерн, структурирующий объекты.</p>
				<h4>Назначение</h4>
				<p>Предоставляет унифицированный интерфейс вместо набора интерфейсов некоторой подсистемы. Фасад определяет интерфейс более высокого уровня, который упрощает использование подсистемы.</p>
				<h4>Мотивация</h4>
				<p>Разбиение на подсистемы облегчает проектирование сложной системы в целом.	Общая цель всякого проектирования - свести к минимуму зависимость подсистем	друг от друга и обмен информацией между ними. Один из способов решения этой задачи - введение объекта фасад, предоставляющий единый упрощенный интерфейс к более сложным системным средствам.</p>
				<div class="wrap-image">
					<img src="img/img-pattern/img1508.jpg" alt="" />
				</div>
				<p>Рассмотрим, например, среду программирования, которая дает приложениям доступ к подсистеме компиляции. В этой подсистеме имеются такие классы, как Scanner (лексический анализатор), Parser (синтаксический анализатор),	ProgramNode (узел программы), BytecodeStream (поток байтовых кодов)	и ProgramNodeBuilder (строитель узла программы). Все вместе они составляют компилятор. Некоторым специализированным приложениям, возможно,	понадобится прямой доступ к этим классам. Но для большинства клиентов компилятора такие детали, как синтаксический разбор и генерация кода, обычно не	нужны; им просто требуется откомпилировать некоторую программу. Для таких клиентов применение мощного, но низкоуровневого интерфейса подсистемы компиляции только усложняет задачу.</p>
				<div class="wrap-image">
					<img src="img/img-pattern/img1517.jpg" alt="" />
				</div>
				<p>Чтобы предоставить интерфейс более высокого уровня, изолирующий клиента от этих классов, в подсистему компиляции включен также класс Compiler	(компилятор). Он определяет унифицированный интерфейс ко всем возможностям компилятора. Класс Compiler выступает в роли фасада: предлагает простой интерфейс к более сложной подсистеме. Он «склеивает» классы, реализующие	функциональность компилятора, но не скрывает их полностью. Благодаря фасаду компилятора работа большинства программистов облегчается. При этом те,	кому нужен доступ к средствам низкого уровня, не лишаются его.</p>
				<h4>Применимость</h4>
				<p>Используйте паттерн фасад, когда:</p>
					<ul>
						<li>а хотите предоставить простой интерфейс к сложной подсистеме. Часто подсистемы усложняются по мере развития. Применение большинства паттернов	приводит к появлению меньших классов, но в большем количестве. Такую	подсистему проще повторно использовать и настраивать под конкретные	нужды, но вместе с тем применять подсистему без настройки становится	труднее. Фасад предлагает некоторый вид системы по умолчанию, устраивающий большинство клиентов. И лишь те объекты, которым нужны более	широкие возможности настройки, могут обратиться напрямую к тому, что	находится за фасадом;</li>
						<li>а между клиентами и классами реализации абстракции существует много зависимостей. Фасад позволит отделить подсистему как от клиентов, так	и от других подсистем, что, в свою очередь, способствует повышению степе	ни независимости и переносимости;</li>
						<li>а вы хотите разложить подсистему на отдельные слои. Используйте фасад для	определения точки входа на каждый уровень подсистемы. Если подсисте	мы зависят друг от друга, то зависимость можно упростить, разрешив подсистемам обмениваться информацией только через фасады.</li>
					</ul>
				<h4>Структура</h4>
				<div class="wrap-image">
					<img src="img/img-pattern/img1524.jpg" alt="" />
				</div>
				<h4>Участники</h4>
					<ul>
						<li><p>a Facade (Compiler) - фасад:</p>
							<ul>
								<li>«знает», каким классам подсистемы адресовать запрос;</li>
								<li>делегирует запросы клиентов подходящим объектам внутри подсистемы;</li>				
							</ul>
						</li>
						<li><p>а Классы подсистемы (Scanner, Parser, ProgramNode и т.д.):</p>
							<ul>
								<li>реализуют функциональность подсистемы;</li>
								<li>выполняют работу, порученную объектом Facade;</li>
								<li>ничего не «знают» о существовании фасада, то есть не хранят ссылок на	него.</li>
							</ul>
						</li>
					</ul>
				<h4>Отношения</h4>
				<p>Клиенты общаются с подсистемой, посылая запросы фасаду. Он переадресует их подходящим объектам внутри подсистемы. Хотя основную работу выполняют именно объекты подсистемы, фасаду, возможно, придется преобразовать свой интерфейс в интерфейсы подсистемы.</p>
				<p>Клиенты, пользующиеся фасадом, не имеют прямого доступа к объектам подсистемы.</p>
				<h4>Результаты</h4>
				<p>У паттерна фасад есть следующие преимущества:</p>
					<ul>
						<li>а изолирует клиентов от компонентов подсистемы, уменьшая тем самым число объектов, с которыми клиентам приходится иметь дело, и упрощая рабо ту с подсистемой;</li>
						<li>а позволяет ослабить связанность между подсистемой и ее клиентами. Зачастую компоненты подсистемы сильно связаны. Слабая связанность позволяет видоизменять компоненты, не затрагивая при этом клиентов. Фасадь: помогают разложить систему на слои и структурировать зависимости между	объектами, а также избежать сложных и циклических зависимостей. Это мо	жет оказаться важным, если клиент и подсистема реализуются независимо. Уменьшение числа зависимостей на стадии компиляции чрезвычайно важно в больших системах. Хочется, конечно, чтобы время, уходящее на пере	компиляцию после изменения классов подсистемы, было минимальным	Сокращение числа зависимостей за счет фасадов может уменьшить количество нуждающихся в повторной компиляции файлов после небольшой модификации какой-нибудь важной подсистемы. Фасад может также упростить	процесс переноса системы на другие платформы, поскольку уменьшается ве	роятность того, что в результате изменения одной подсистемы понадобится	изменять и все остальные;</li>
						<li>а фасад не препятствует приложениям напрямую обращаться к классам подсистемы, если это необходимо. Таким образом, у вас есть выбор между простотой и общностью.</li>
					</ul>
				<h4>Реализация</h4>
				<p>При реализации фасада следует обратить внимание на следующие вопросы:<p>
					<ul>
						<li><i>а уменьшение степени связанности клиента с подсистемой.</i> Степень связаности можно значительно уменьшить, если сделать класс Facade абстрактным. Его конкретные подклассы будут соответствовать различным реализациям подсистемы. Тогда клиенты смогут взаимодействовать с подсистемой	через интерфейс абстрактного класса Facade. Это изолирует клиентов от ин	формации о том, какая реализация подсистемы используется.	Вместо порождения подклассов можно сконфигурировать объект Facade	различными объектами подсистем. Для настройки фасада достаточно заменить один или несколько таких объектов;</li>
						<li><i>а открытые и закрытые классы подсистем.</i> Подсистема похожа на класс в том отношении, что у обоих есть интерфейсы и оба что-то инкапсулируют.	Класс инкапсулирует состояние и операции, а подсистема - классы. И если полезно различать открытый и закрытый интерфейсы класса, то не менее разумно говорить об открытом и закрытом интерфейсах подсистемы.								Открытый интерфейс подсистемы состоит из классов, к которым имеют доступ все клиенты; закрытый интерфейс доступен только для расширения	подсистемы. Класс Facade, конечно же, является частью открытого интерфейса, но это не единственная часть. Другие классы подсистемы также могут быть открытыми. Например, в системе компиляции классы Parser	и Scanner - часть открытого интерфейса.	Делать классы подсистемы закрытыми иногда полезно, но это поддерживается немногими объектно-ориентированными языками. И в C++, и в Smalltalk	для классов традиционно использовалось глобальное пространство имен. Однако комитет по стандартизации C++ добавил к языку пространства имен	[Str94], и это позволило разрешать доступ только к открытым классам подсистемы.</li>
					</ul>
				<h4>Пример кода</h4>
				<p>Рассмотрим более подробно, как возвести фасад вокруг подсистемы компиляции.	В подсистеме компиляции определен класс BytecodeStream, который реализует поток объектов Bytecode. Объект Bytecode инкапсулирует байтовый	код, с помощью которого описываются машинные команды. В этой же подсистеме определен еще класс Token для объектов, инкапсулирующих лексемы языка												программирования.</p>
				<p>Класс Scanner принимает на входе поток символов и генерирует поток лексем, по одной каждый раз:</p>
					<pre>
					class Scanner {
					&nbsp;&nbsp;public:
					&nbsp;&nbsp;vScanner(istream&);
					&nbsp;&nbsp;virtual -Scanner();
					&nbsp;&nbsp;virtual Token& Scan();
					&nbsp;&nbsp;private:
					&nbsp;&nbsp;istream& _inputStream;
					};
					</pre>
				<p>Класс Parser использует класс ProgramNodeBuilder для построения дерева разбора из лексем, возвращенных классом Scanner:</p>
					<pre>
					class Parser {
					&nbsp;&nbsp;public:
					&nbsp;&nbsp;Parser();
					&nbsp;&nbsp;virtual -Parser();
					&nbsp;&nbsp;virtual void Parse(Scanners, ProgramNodeBuilder&);
					};
					</pre>
				<p>Parser вызывает ProgramNodeBuilder для инкрементного построения дерева. Взаимодействие этих классов описывается паттерном строитель:</p>
					<pre>
					class ProgramNodeBuilder {
					&nbsp;&nbsp;public:
					&nbsp;&nbsp;ProgramNodeBuilder();
					&nbsp;&nbsp;virtual ProgramNode* NewVariable(
					&nbsp;&nbsp;const char* variableName
					&nbsp;&nbsp;) const;
					&nbsp;&nbsp;virtual ProgramNode* NewAssignment(
					&nbsp;&nbsp;ProgramNode* variable, ProgramNode* expression
					&nbsp;&nbsp;) const;
					&nbsp;&nbsp;virtual ProgramNode* NewReturnStatement(
					&nbsp;&nbsp;ProgramNode* value
					&nbsp;&nbsp;) const;
					&nbsp;&nbsp;virtual ProgramNode* NewCondition(
					&nbsp;&nbsp;ProgramNode* condition,
					&nbsp;&nbsp;ProgramNode* truePart, ProgramNode* falsePart
					&nbsp;&nbsp;) const;
					&nbsp;&nbsp;// ...
					&nbsp;&nbsp;ProgramNode* GetRootNode();
					&nbsp;&nbsp;private:
					&nbsp;&nbsp;ProgramNode* _node;
					};
					</pre>
				<p>Дерево разбора состоит из экземпляров подклассов класса ProgramNode, таких как StatementNode, ExpressionNode и т.д. Иерархия классов ProgramNode — это пример паттерна компоновщик. Класс ProgramNode определяет интерфейс для	манипулирования узлом программы и его потомками, если таковые имеются:</p>
					<pre>
					class ProgramNode {
					&nbsp;&nbsp;public:
					&nbsp;&nbsp;// манипулирование узлом программы
					&nbsp;&nbsp;virtual void GetSourcePosition(int& line, int& index);
					&nbsp;&nbsp;// ...
					&nbsp;&nbsp;// манипулирование потомками
					&nbsp;&nbsp;virtual void Add(ProgramNode*);
					&nbsp;&nbsp;virtual void Remove(ProgramNode*);
					&nbsp;&nbsp;// .. .
					&nbsp;&nbsp;virtual void Traverse(CodeGeneratork);
					&nbsp;&nbsp;protected:
					&nbsp;&nbsp;ProgramNode();
					};
					</pre>
				<p>Операция Traverse (обход) принимает объект CodeGenerator (кодогенератор) в качестве параметра. Подклассы ProgramNode используют этот объект для генерации машинного кода в форме объектов Bytecode, которые помещаются в поток BytecodeStream. Класс CodeGenerator описывается паттерном посетитель:</p>
					<pre>
					class CodeGenerator {
					&nbsp;&nbsp;public:
					&nbsp;&nbsp;virtual void Visit(StatementNode*);
					&nbsp;&nbsp;virtual void Visit(ExpressionNode*);
					&nbsp;&nbsp;// ...
					&nbsp;&nbsp;protected:
					&nbsp;&nbsp;CodeGenerator(BytecodeStreamk);
					&nbsp;&nbsp;protected:
				 &nbsp;&nbsp;BytecodeStreamk _output;
					};
					</pre>
				<p>У CodeGenerator есть подклассы, например StackMachineCodeGenerator	и RISCCodeGenerator, генерирующие машинный код для различных аппаратных	архитектур.</p>
				<p>Каждый подкласс ProgramNode реализует операцию Traverse и обращается к ней для обхода своих потомков. Каждый потомок рекурсивно делает то же самое для своих потомков. Например, в подклассе ExpressionNode (узел выражения) операция Traverse определена так:</p>
					<pre>
					void ExpressionNode::Traverse (CodeGenerator& eg) {
					&nbsp;&nbsp;eg.Visit(this);
					&nbsp;&nbsp;ListIterator programnode i(_children);
					&nbsp;&nbsp;for (i. First ( ) ; ! i . IsDone () ; i.NextO) {
					&nbsp;&nbsp;i.Currentltem()->Traverse(eg);
					&nbsp;&nbsp;}
					}
					</pre>
				<p>Классы, о которых мы говорили до сих пор, составляют подсистему компиляции. А теперь введем класс Compiler, который будет служить фасадом, позволяющим собрать все эти фрагменты воедино. Класс Compiler предоставляет простой	интерфейс для компилирования исходного текста и генерации кода для конкретной машины:</p>
					<pre>
					class Compiler {
					&nbsp;&nbsp;public:
					&nbsp;&nbsp;Compiler();
					&nbsp;&nbsp;virtual void Compile(istream&, BytecodeStream&);
					&nbsp;&nbsp;};
					&nbsp;&nbsp;void Compiler::Compile (
					&nbsp;&nbsp;istream& input, BytecodeStreamk output
					&nbsp;&nbsp;) {
					&nbsp;&nbsp;Scanner scanner(input);
					&nbsp;&nbsp;ProgramNodeBuilder builder;
					&nbsp;&nbsp;Parser parser;
					&nbsp;&nbsp;parser.Parse(scanner, builder);
					&nbsp;&nbsp;RISCCodeGenerator generator(output);
					&nbsp;&nbsp;ProgramNode* parseTree = builder.GetRootNode();
					&nbsp;&nbsp;parseTree->Traverse(generator);
					}
					</pre>
				<p>В этой реализации жестко «зашит» тип кодогенератора, поэтому программисту	не нужно явно задавать целевую архитектуру. Это может быть вполне разумно, когда	есть всего одна такая архитектура. Если же это не так, можно было бы изменить конструктор класса Compiler, чтобы он принимал объект CodeGenerator в качестве	параметра. Тогда программист указывал бы, каким генератором пользоваться при инстанцировании объекта Compiler. Фасад компилятора можно параметризовать	и другими участниками, скажем, объектами Scanner и ProgramNodeBuilder, что								повышает гибкость, но в то же время сводит на нет основную цель фасада - предоставление упрощенного интерфейса для наиболее распространенного случая.</p>
				<h4>Известные применения</h4>
				<p>Пример компилятора в разделе «Пример кода» навеян идеями из системы компиляции языка ObjectWorks\Smalltalk [РагЭО].</p>
				<p>В каркасе ЕТ++ [WGM88] приложение может иметь встроенные средства инспектирования объектов во время выполнения. Они реализуются в отдельной	подсистеме, включающей класс фасада с именем ProgrammingEnvironment.	Этот фасад определяет такие операции, как InspectObject и InspectClass	для доступа к инспекторам.</p>
				<p>Приложение, написанное в среде ЕТ++, может также запретить поддержку	инспектирования. В таком случае класс ProgrammingEnvironment реализует	соответствующие запросы как пустые операции, не делающие ничего. Только подкласс ETProgrammingEnvironment реализует эти операции так, что они отображают окна соответствующих инспекторов. Приложению неизвестно, доступно						инспектирование или нет. Здесь мы встречаем пример абстрактной связанности	между приложением и подсистемой инспектирования.</p>
				<p>В операционной системе Choices [CIRM93] фасады используются для составления одного каркаса из нескольких. Ключевыми абстракциями в системе Choices	являются процессы, память и адресные пространства. Для каждой из них есть соответствующая подсистема, реализованная в виде каркаса. Это обеспечивает поддержку переноса Choices на разные аппаратные платформы. У двух таких подсистем есть	«представители», то есть фасады. Они называются FileSystemlnterface (память) и Domain (адресные пространства).</p>
				<div class="wrap-image">
					<img src="img/img-pattern/img1551.jpg" alt="" />
				</div>
				<p>Например, для каркаса виртуальной памяти фасадом служит Domain. Класс	Domain представляет адресное пространство. Он обеспечивает отображение между	виртуальными адресами и смещениями объектов в памяти, файле или на устройстве длительного хранения. Базовые операции класса Domain поддерживают добавление объекта в память по указанному адресу, удаление объекта из памяти		и обработку ошибок отсутствия страниц.</p>
				<p>Как видно из вышеприведенной диаграммы, внутри подсистемы виртуальной	памяти используются следующие компоненты:</p>
					<ul>
						<li>a MemoryObject представляет объекты данных;</li>
						<li>a MemoryObj ectCache кэширует данные из объектов MemoryObj ects в физической памяти. MemoryObj ectCache - это не что иное, как объект Стратегия, в котором локализована политика кэширования;</li>
						<li>a AddressTranslat ion инкапсулирует особенности оборудования трансляции адресов.</li>
					</ul>
				<p>Операция RepairFault вызывается при возникновении ошибки из-за отсутствия страницы. Domain находит объект в памяти по адресу, где произошла ошибка и делегирует операцию RepairFault кэшу, ассоциированному с этим объектом. Поведение объектов Domain можно настроить, заменив их компоненты.</p>
				<h4>Родственные паттерны</h4>
				<p>Паттерн абстрактная фабрика допустимо использовать вместе с фасадом,	чтобы предоставить интерфейс для создания объектов подсистем способом, не зависимым от этих подсистем. Абстрактная фабрика может выступать и как альтернатива фасаду, чтобы скрыть платформенно-зависимые классы.</p>
				<p>Паттерн посредник аналогичен фасаду в том смысле, что абстрагирует функциональность существующих классов. Однако назначение посредника - абстрагировать произвольное взаимодействие между «сотрудничающими» объектами. Часто он централизует функциональность, не присущую ни одному из них. Коллеги посредника обмениваются информацией именно с ним, а не напрямую между собой. Напротив, фасад просто абстрагирует интерфейс объектов подсистемы,	чтобы ими было проще пользоваться. Он не определяет новой функциональности,	и классам подсистемы ничего неизвестно о его существовании.</p>
				<p>Обычно требуется только один фасад. Поэтому объекты фасадов часто бывают одиночками.</p>
			</div>
		</section>
	</main>
	<footer>
		<a href="index.html" class="go-home-button">&nbsp;</a>
		<a href="#promo" class="go-top">&nbsp;</a>
		<div class="container">
			<p>&#169; Copyright 2016 &nbsp; <a href="#">#HardhatsTeam</a></p>
		</div>
	</footer>	
</body>
</html>