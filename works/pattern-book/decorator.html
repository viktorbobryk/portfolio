<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta name="description" content="Object-Oriented Software" />
	<meta name="keywords" content="Design, Patterns, Elements, Reusable, Object-Oriented, Software" />
	<title>Decorator Page</title> <!-- !!! Page name !!! -->
	<link rel="stylesheet" href="css/reset.css" />
	<link rel="stylesheet" href="css/style.css" />
	<!-- <link href='https://fonts.googleapis.com/css?family=Lobster|Open+Sans:400,300,700,300italic,600&subset=latin,cyrillic' rel='stylesheet' type='text/css' /> -->
</head>
<body>
	<header>
		<a href="index.html" class="go-home-button">&nbsp;</a>
		<div class="container">
			<nav>
				<ul>
					<li><a href="adapter.html">Паттерн Adapter</a></li>
					<li><a href="bridge.html">Паттерн Bridge</a></li>
					<li><a href="composite.html">Паттерн Composite</a></li>
					<li><a href="decorator.html" class="active">Паттерн Decorator</a></li> <!-- !!! link MUST have .active class on corresponding page !!! -->
					<li><a href="facade.html">Паттерн Facade</a></li>
					<li><a href="flyweight.html">Паттерн Flyweight</a></li>
					<li><a href="proxy.html">Паттерн Proxy</a></li>
				</ul>
			</nav>
		</div>
	</header>
	<main>
		<section class="promo-section decorator-promo">
		<div class="overlay"></div>
			<div class="container">
				<div class="titles-wrapper">
						<h1>Паттерн Decorator</h1>
				</div>
			</div>
		</section>
		<section class="content-section">
			<div class="container">
			<h3>Название и классификация паттерна</h3>
			<p>Декоратор - паттерн, структурирующий объекты.</p>
			<h4>Назначение</h4>
			<p>Динамически добавляет объекту новые обязанности. Является гибкой альтер нативой порождению подклассов с целью расширения функциональности.</p>
			<p>Известен также под именем</p>
			<p><b>Wrapper (обертка).</b></p>
			<h4>Мотивация</h4>
			<p>Иногда бывает нужно возложить дополнительные обязанности на отдельный объект, а не на класс в целом. Так, библиотека для построения графических ин терфейсов пользователя должна «уметь» добавлять новое свойство, скажем, рамку или новое поведение (например, возможность прокрутки к любому элементуинтерфейса).</p>
			<!-- !!! TWO COLUMN LAYOUT !!! --><p class="paragraph-two-column">Добавить новые обязанности допустимо с помощью наследования. При насле довании классу с рамкой вокруг каждого экземпляра подкласса будет рисоваться	рамка. Однако это решение статическое, а значит, недостаточно гибкое. Клиент не	может управлять оформлением компонента рамкой.</p>
			<p>Более гибким является другой подход: поместить компонент в другой объект, называемый <i>декоратором</i>, который как раз и добавляет рамку. Декоратор следует интерфейсу декорируемого объекта, поэтому его присутствие прозрачно дляклиентов компонента. Декоратор переадресует запросы внутреннему компоненту, но может выполнять и дополнительные действия (например, рисовать рамку) до или после переадресации. Поскольку декораторы прозрачны, они могут вкладываться друг в друга, добавляя тем самым любое число новых обязанностей.</p>
			<div class="wrap-image">
				<img src="img/img-pattern/img1450.jpg" alt="" />
			</div>
			<p>Предположим, что имеется объект класса Text View, который отображаеттекст в окне. По умолчанию Text View не имеет полос прокрутки, поскольку они не всегда нужны. Но при необходимости их удастся добавить с помощью декоратора ScrollDecorator. Допустим, что еще мы хотим добавить жирную сплошную рамку вокруг объекта TextView. Здесь может помочь декоратор BorderDecorat or.	Мы просто компонуем оба декоратора с BorderDecorator и получаем искомый	результат.</p>
			<p>Ниже на диаграмме показано, как композиция объекта TextView с объектами BorderDecorator и ScrollDecorator порождает элемент для ввода текста, окруженный рамкой и снабженный полосой прокрутки.</p>
			<div class="wrap-image">
				<img src="img/img-pattern/img1452.jpg" alt="" />
			</div>
			<p>Классы ScrollDecorator и BorderDecorator являются подклассамиDecorator - абстрактного класса, который представляет визуальные компоненты, применяемые для оформления других визуальных компонентов.</p>
			<p>VisualComponent - это абстрактный класс для представления визуальных объектов. В нем определен интерфейс для рисования и обработки событий. Отме тим, что класс Decorator просто переадресует запросы на рисование своему компоненту, а его подклассы могут расширять эту операцию.</p>
			<div class="wrap-image">
				<img src="img/img-pattern/img1459.jpg" alt="" />
			</div>
			<p>Подклассы Decorator могут добавлять любые операции для обеспечения необходимой функциональности. Так, операция ScrollTo объекта ScrollDecorator позволяет другим объектам выполнять прокрутку, если им известно о присутствии объекта ScrollDecorator. Важная особенность этого паттерна состоит в том, что декораторы могут употребляться везде, где возможно появление самого объекта VisualComponent. Поэтому клиент не может отличить декорированный	объект от недекорированного, а значит, и никоим образом не зависит от наличия	или отсутствия оформлений.</p>
			<h4>Применимость</h4>
			<p>Используйте паттерн декоратор:</p>
			<ul>
				<li>для динамического, прозрачного для клиентов добавления обязанностей объектам;</li>
				<li>а для реализации обязанностей, которые могут быть сняты с объекта;</li>
				<li>а когда расширение путем порождения подклассов по каким-то причинам нудобно или невозможно. Иногда приходится реализовывать много независимых расширений, так что порождение подклассов для поддержки всех
				возможных комбинаций приведет к комбинаторному росту их числа. В других случаях определение класса может быть скрыто или почему-либо ещенедоступно, так что породить от него подкласс нельзя.</li>
			</ul>
			<h4>Структура</h4>
			<div class="wrap-image">
				<img src="img/img-pattern/img1466.jpg" alt="" />
			</div>
			<h4>Участники</h4>
			<ul>
				<li>Component (VisualComponent) - компонент: - определяет интерфейс для объектов, на которые могут быть динамически возложены дополнительные обязанности;</li>
				<li>ConcreteComponent (TextView) - конкретный компонент: - определяет объект, на который возлагаются дополнительные обязанности;</li>
				<li>Decorator - декоратор: - хранит ссылку на объект Component и определяет интерфейс, соответствующий интерфейсу Component;</li>
				<li>ConcreteDecorator (BorderDecorator, ScrollDecorator) - конкретный декоратор: возлагает дополнительные обязанности на компонент.</li>
			</ul>
			<h4>Отношения</h4>
			<p>Decorator переадресует запросы объекту Component. Может выполнять и дополнительные операции до и после переадресации.</p>
			<h4>Результаты</h4>
			<p>У паттерна декоратор есть, по крайней мере, два плюса и два минуса:</p>
			<ul>
				<li>а большая гибкость, нежели у статического наследования. Паттерн декоратор	позволяет более гибко добавлять объекту новые обязанности, чем было бы возможно в случае статического (множественного) наследования. Декоратор может добавлять и удалять обязанности во время выполнения программы. При	пользовании же наследования требуется создавать новый класс для каждой дополнительной обязанности (например, Bor.deredScrollableTextView,	BorderedTextView), что ведет к увеличению числа классов и, как следствие,	к возрастанию сложности системы. Кроме того, применение нескольких декораторов к одному компоненту позволяет произвольным образом сочетать обязанности. Декораторы позволяют легко добавить одно и то же свойство дважды. На пример, чтобы окружить объект Text View ойной рамкой, нужно просто добавить два декоратора BorderDecorators. Двойное наследование классу Border в лучшем случае чревато ошибками;</li>
				<li>а позволяет избежать перегруженных функциями классов на верхних уровняхиерархии. Декоратор разрешает добавлять новые обязанности по мере необ	ходимости. Вместо того чтобы пытаться поддержать все мыслимые возможности в одном сложном, допускающем разностороннюю настройку классе,	вы можете определить простой класс и постепенно наращивать его функци	ональность с помощью декораторов. В результате приложение уже не платит за неиспользуемые функции. Нетрудно также определять новые видыдекораторов независимо от классов, которые они расширяют, даже если первоначально такие расширения не планировались. При расширении же сложного класса обычно приходится вникать в детали, не имеющие отношения к добавляемой функции;</li>
				<li>а декоратор и его компонент не идентичны. Декоратор действует как про	зрачное обрамление. Но декорированный компонент все же не идентичен исходному. При использовании декораторов это следует иметь в виду;</li>
				<li>а множество мелких объектов. При использовании в проекте паттерна декоратор нередко получается система, составленная из большого числа мелких	бъектов, которые похожи друг на друга и различаются только способом взаимосвязи, а не классом и не значениями своих внутренних переменных. Хотя	проектировщик, разбирающийся в устройстве такой системы, может легко	настроить ее, но изучать и отлаживать ее очень тяжело.</li>
			</ul>
			<h4>Реализация</h4>
			<p>Применение паттерна декоратор требует рассмотрения нескольких вопросов:</p>
			<ul>
				<li>
					<i>а соответствие интерфейсов.</i>
					Интерфейс декоратора должен соответствовать интерфейсу декорируемого компонента. Поэтому классы ConcreteDecorator должны наследовать общему классу (по крайней мере, в C++);
				</li>
				<li>
					<i>а отсутствие абстрактного класса Decorator.</i>
					Нет необходимости определять абстрактный класс Decorator, если планируется добавить всего одну обязанность. Так часто происходит, когда вы работаете с уже существующей иерархией классов, а не проектируете новую.В таком случае ответственность за переадресацию запросов, которую обычно несет класс Decorator,можно возложить непосредственно на ConcreteDecorator;
				</li>
				<li>
					<i>а облегченные классы Component.</i>
					Чтобы можно было гарантировать соответствие интерфейсов, компоненты и декораторы должны наследовать общему классу Component. Важно, чтобы этот класс был настолько легким, насколько возможно. Иными словами, он должен определять интерфейс, а не хранить данные. В противном случае декораторы могут стать весьма тяжеловесными,	и применять их в большом количестве будет накладно. Включение большого числа функций в класс Component также увеличивает вероятность, что кон кретным подклассам придется платить за то, что им не нужно;
				</li>
				<li>
					<i>а изменение облика, а не внутреннего устройства объекта.</i>
					Декоратор можно рассматривать как появившуюся у объекта оболочку, которая изменяет его
					поведение. Альтернатива - изменение внутреннего устройства объекта, хо рошим примером чего может служить паттерн стратегия. Стратегии лучше подходят в ситуациях, когда класс Component уже доста точно тяжел, так что применение паттерна декоратор обходится слишком дорого. В паттерне стратегия компоненты передают часть своей функцио нальности отдельному объекту-стратегии, поэтому изменить или расширить
					поведение компонента допустимо, заменив этот объект. Например, мы можем поддержать разные стили рамок, поручив рисование рамки специальному объекту Border. Объект Border является примером
					объекта-стратегии: в данном случае он инкапсулирует стратегию рисования	рамки. Число стратегий может быть любым, поэтому эффект такой же, как	от рекурсивной вложенности декораторов.
					Например, в системах МасАрр 3.0 [Арр89] и Bedrock [Sym93a] графические	компоненты, называемые видами (views), хранят список объектов-оформителей (adoraer), которые могут добавлять различные оформления вроде границ	к виду. Если к виду присоединены такие объекты, он дает им возможность вы полнить свои функции. МасАрр и Bedrock вынуждены предоставить дос	туп к этим операциям, поскольку класс View весьма тяжел. Было бы слишком расточительно использовать полномасштабный объект этого класса только для	того, чтобы добавить рамку.	Поскольку паттерн декоратор изменяет лишь внешний облик компонента,
					последнему ничего не надо «знать» о своих декораторах, то есть декораторы	прозрачны для компонента.
				</li>
			</ul>
				<div class="wrap-image">
					<img src="img/img-pattern/img1478.jpg" alt="" />
				</div>
				<p>В случае стратегий самому компоненту известно о возможных расширени ях. Поэтому он должен располагать информацией обо всех стратегиях и ссы	латься на них.</p>
				<div class="wrap-image">
					<img src="img/img-pattern/img1480.jpg" alt="" />
				</div>
				<p>При использовании подхода, основанного на стратегиях, может возникнуть необходимость модифицировать компонент, чтобы он соответствовал ново	му расширению. С другой стороны, у стратегии может быть свой собствен	ный специализированный интерфейс, тогда как интерфейс декоратора дол	жен повторять интерфейс компонента. Например, стратегии рисования	рамки необходимо определить всего лишь интерфейс для этой операции	(DrawBorder, GetWidth и т.д.), то есть класс стратегии может быть лег	ким, несмотря на тяжеловесность компонента.	Системы МасАрр и Bedrock применяют такой подход не только для оформ-
				ления видов, но и для расширения особенностей поведения объектов, свя	занных с обработкой событий. В обеих системах вид ведет список объектов	поведения, которые могут модифицировать и перехватывать события. Каж	дому зарегистрированному объекту поведения вид предоставляет возмож	ность обработать событие до того, как оно будет передано незарегистриро	ванным объектам такого рода, за счет чего достигается переопределение	поведения. Можно, например, декорировать вид специальной поддержкой	работы с клавиатурой, если зарегистрировать объект поведения, который	перехватывает и обрабатывает события нажатия клавиш.</p>
			
			<h4>Пример кода</h4>
			<p>В следующем примере показано, как реализовать декораторы пользователь	ского интерфейса в программе на C++. Мы будем предполагать, что класс компо	нента называется VisualComponent:</p>
			<pre>
				class VisualComponent {
				&nbsp;&nbsp;public:
				&nbsp;&nbsp;VisualComponent();
				&nbsp;&nbsp;virtual void Draw();
				&nbsp;&nbsp;virtual void Resize();
				&nbsp;&nbsp;// ...
				};
			</pre>

			<p>Определим подкласс класса VisualComponent с именем Decorator, от ко	торого затем породим подклассы, реализующие различные оформления:</p>
			<pre>
				class Decorator : public VisualComponent {
				&nbsp;&nbsp;public:
				&nbsp;&nbsp;Decorator(VisualComponent*);
				&nbsp;&nbsp;virtual void Draw();
				&nbsp;&nbsp;virtual void Resize();
				&nbsp;&nbsp;// ...
				&nbsp;&nbsp;private:
				&nbsp;&nbsp;VisualComponent* „component;
				};
			</pre>
			<p>Объект класса Decorator декорирует объект VisualComponent, на который	ссылается переменная экземпляра _component, инициализируемая в конструкторе. Для каждой операции в интерфейсе VisualComponent в классе Decorator опре	делена реализация по умолчанию, передающая запросы объекту, на который ве	дет ссылка _component:</p>
			<pre>
				void Decorator::Draw () {
				&nbsp;&nbsp;_component->Draw();
				}
				void Decorator: :Resize () {
				&nbsp;&nbsp;_component->Resize ( ) ;
				}
			</pre>
			<p>Подклассы Decorator определяют специализированные операции. Например, класс BorderDecorator добавляет к своему внутреннему компоненту рамку. BorderDecorator - это подкласс Decorator, где операция Draw замещена	так, что рисует рамку. В этом классе определена также закрытая вспомогательная	операция DrawBorder, которая, собственно, и изображает рамку. Реализации всех	остальных операций этот подкласс наследует от Decorator:</p>
			<pre>
				class BorderDecorator : public Decorator {
				&nbsp;&nbsp;public:
				&nbsp;&nbsp;BorderDecorator (VisualComponent*, int borderWidth) ;
				&nbsp;&nbsp;virtual void Draw();
				&nbsp;&nbsp;private:
				&nbsp;&nbsp;void DrawBorder ( int ) ;
				&nbsp;&nbsp;private:
				&nbsp;&nbsp;int _width;
				&nbsp;&nbsp;void BorderDecorator :: Draw () {
				&nbsp;&nbsp;Decorator : : Draw ( ) ;
				&nbsp;&nbsp;DrawBorder (_width) ;
				}	
			</pre>
			<p>Подклассы ScrollDecorator и DropShadowDecorator, которые добавят визуальному компоненту возможность прокрутки и оттенения можно реализовать	аналогично.</p>
			<p>Теперь нам удастся скомпоновать экземпляры этих классов для получения	различных оформлений. Ниже показано, как использовать декораторы для созда	ния прокручиваемого компонента Text View с рамкой.</p>
			<p>Во-первых, нужен какой-то способ поместить визуальный компонент в окон	ный объект. Предположим, что в нашем классе Window для этой цели имеется	операция SetContents:</p>
			<pre>
				void Window: : SetContents (VisualComponent* contents) {
				&nbsp;&nbsp;// ...
				}
			</pre>
			<p>Теперь можно создать поле для ввода текста и окно, в котором будет находить	ся это поле:</p>
			<pre>
				Window* window = new Window;
				TextView* textView = new TextView;
			</pre>
			<p>TextView - подкласс VisualComponent, значит, мы могли бы поместить его	в окно:</p>
			<pre>
				window->SetContents(textView);
			</pre>
			<p>Но нам нужно поле ввода с рамкой и возможностью прокрутки. Поэтому пред	варительно мы его надлежащим образом оформим:</p>
			<pre>
				window->SetContents (
				&nbsp;&nbsp;new BorderDecorator (
				&nbsp;&nbsp;&nbsp;&nbsp;new ScrollDecorator(textView), 1
				&nbsp;&nbsp;)
				);
			</pre>
			<p>Поскольку класс Window обращается к своему содержимому только через ин	терфейс VisualComponent, то ему неизвестно о присутствии декоратора. Клиент	при желании может сохранить ссылку на само поле ввода, если ему нужно работать	с ним непосредственно, например вызывать операции, не входящие в интерфейс	VisualComponent. Клиенты, которым важна идентичность объекта, также долж	ны обращаться к нему напрямую.</p>
			<h4>Известные применения</h4>
			<!-- !!! THREE COLUMN LAYOUT !!! --><p class="paragraph-three-column">Во многих библиотеках для построения объектно-ориентированных интерфей	сов пользователя декораторы применяются для добавления к виджетам графичес	ких оформлений. В качестве примеров можно назвать Interviews [LVC89, LCI+92],	ЕТ++ [WGM88] и библиотеку классов ObjectWorks\Smalltalk [РагЭО]. Другие ва	рианты применения паттерна декоратор - это класс DebuggingGlyph из библи	теки Interviews и PassivityWrapper из ParcPlace Smalltalk. DebuggingGlyph	печатает отладочную информацию до и после того, как переадресует запрос на	размещение своему компоненту. Эта информация может быть полезна для анали	за и отладки стратегии размещения объектов в сложном контейнере. Класс	PassivityWrapper позволяет разрешить или запретить взаимодействие компо	нента с пользователем.</p>
			<p>Но применение паттерна декоратор никоим образом не ограничивается гра	фическими интерфейсами пользователя, как показывает следующий пример, ос	нованный на потоковых классах из каркаса ЕТ++ [WGM88].</p>
			<p>Поток - это фундаментальная абстракция в большинстве средств ввода/вы	вода. Он может предоставлять интерфейс для преобразования объектов в после	довательность байтов или символов. Это позволяет записать объект в файл или	буфер в памяти и впоследствии извлечь его оттуда. Самый очевидный способ сде	лать это - определить абстрактный класс Stream с подклассами MemoryStream	и FileStream. Предположим-, однако, что нам хотелось бы еще уметь:</p>
			<ul>
				<li>а компрессировать данные в потоке, применяя различные алгоритмы сжатия	(кодирование повторяющихся серий, алгоритм Лемпеля-Зива и т.д.);</li>
				<li>а преобразовывать данные в 7-битные символы кода ASCII для передачи по	каналу связи.</li>
			</ul>
			<p>Паттерн декоратор позволяет весьма элегантно добавить такие обязанности	потокам. На диаграмме ниже показано одно из возможных решений задачи.</p>
			<div class="wrap-image">
				<img src="img/img-pattern/img1503.jpg" alt="" />
			</div>
			<p>Абстрактный класс Stream имеет внутренний буфер и предоставляет опера	ции для помещения данных в поток (Putlnt, PutString). Как только буфер за	полняется, Stream вызывает абстрактную операцию HandleBufferFull, кото	рая выполняет реальное перемещение данных. В классе Fi leSt ream эта операция	замещается так, что буфер записывается в файл.</p>
			<p>Ключевым здесь является класс StreamDecorator. Именно в нем хранится	ссылка на тот поток-компонент, которому переадресуются все запросы. Подклас	сы StreamDecorator замещают операцию HandleBufferFull и выполняют до	полнительные действия, перед тем как вызвать реализацию этой операции в клас	се StreamDecorator.</p>
			<p>Например, подкласс CompressingStream сжимает данные, a ASCII7Stream	конвертирует их в 7-битный код ASCII. Теперь, для того чтобы создать объект	FileStream, который одновременно сжимает данные и преобразует результат	в 7-битный код, достаточно просто декорировать FileStream с использованием	CompressingStream и ASCII7Stream:</p>
			<pre>
				Stream* aStream = new CompressingStream (
				&nbsp;&nbsp;new ASCII7Stream(
				&nbsp;&nbsp;&nbsp;&nbsp;new FileStream ( "aFileName")
				&nbsp;&nbsp;)
				);
				aStream->Put!nt(12);
				aStream->PutString("aString");
			</pre>	
			<h4>Родственные паттерны</h4>
			<p>Адаптер: если декоратор изменяет только обязанности объекта, но не его ин	терфейс, то адаптер придает объекту совершенно новый интерфейс.</p>
			</div>
		</section>
	</main>
	<footer>
		<div class="container">
			<p>&#169; Copyright 2016 &nbsp; <a href="#">#HardhatsTeam</a></p>
		</div>
	</footer>
</body>
</html>