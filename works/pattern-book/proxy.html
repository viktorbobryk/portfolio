<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta name="description" content="Object-Oriented Software" />
	<meta name="keywords" content="Design, Patterns, Elements, Reusable, Object-Oriented, Software" />
	<title>Proxy page</title>
	<link rel="stylesheet" href="css/reset.css" />
	<link rel="stylesheet" href="css/style.css" />
	<!-- <link href='https://fonts.googleapis.com/css?family=Lobster|Open+Sans:400,300,700,300italic,600&subset=latin,cyrillic' rel='stylesheet' type='text/css' /> -->
</head>
<body>
	<header>
		<a href="index.html" class="go-home-button">&nbsp;</a>
		<div class="container">
			<nav>
				<ul>
					<li><a href="adapter.html">Паттерн Adapter</a></li>
					<li><a href="bridge.html">Паттерн Bridge</a></li>
					<li><a href="composite.html">Паттерн Composite</a></li>
					<li><a href="decorator.html">Паттерн Decorator</a></li> 
					<li><a href="facade.html">Паттерн Facade</a></li>
					<li><a href="flyweight.html">Паттерн Flyweight</a></li>
					<li><a href="proxy.html" class="active">Паттерн Proxy</a></li><!-- !!! link MUST have .active class on corresponding page !!! -->
				</ul>
			</nav>
		</div>
	</header>
	<main>
		<section class="promo-section proxy-promo">
		<div class="overlay"></div>
			<div class="container">
				<div class="titles-wrapper">
					<h1>Паттерн Proxy</h1>
				</div>
			</div>
		</section>		
		<section class="content-section">
			<div class="container">				
			<h3>Название и классификация паттерна</h3>
			<p>Заместитель - паттерн, структурирующий объекты.</p>
			<h4>Назначение</h4>
			<p>Является суррогатом другого объекта и контролирует доступ к нему.</p>
			<h4>Известен также под именем</h4>
			<p>Surrogate (суррогат).</p>
			<h4>Мотивация</h4>
			<p>Разумно управлять доступом к объекту, поскольку тогда можно отложить расходы на создание и инициализацию до момента, когда объект действительно понадобится. Рассмотрим редактор документов, который допускает встраивание в документ графических объектов. Затраты на создание некоторых таких объектов,	например больших растровых изображений, могут быть весьма значительны. Но	документ должен открываться быстро, поэтому следует избегать создания всех	«тяжелых» объектов на стадии открытия (да и вообще это излишне, поскольку не	все они будут видны одновременно).</p>
			<p>В связи с такими ограничениями кажется разумным создавать «тяжелые»	объекты по требованию. Это означает «когда изображение становится видимым».	Но что поместить в документ вместо изображения? И как, не усложняя реализации редактора, скрыть то, что изображение создается по требованию? Например,	оптимизация не должна отражаться на коде, отвечающем за рисование и форматирование.</p>
			<p>Решение состоит в том, чтобы использовать другой объект - заместитель	изображения, который временно подставляется вместо реального изображения.	Заместитель ведет себя точно так же, как само изображение, и выполняет при необходимости его инстанцирование.</p>
			<div class="wrap-image">
			  <img src="img/img-pattern/img1646.jpg" alt="" />
			</div>
			<p>Заместитель создает настоящее изображение, только если редактор документа вызовет операцию Draw. Все последующие запросы заместитель переадресует	непосредственно изображению. Поэтому после создания изображения он должен	сохранить ссылку на него.</p>	
			<p>Предположим, что изображения хранятся в отдельных файлах. В таком случае мы можем использовать имя файла как ссылку на реальный объект. Заместитель хранит также размер изображения, то есть длину и ширину. «Зная» ее, заместитель может отвечать на запросы форматера о своем размере, не инстанцируяизображение.</p>
			<p>На следующей диаграмме классов этот пример показан более подробно.</p>
			<div class="wrap-image">
			  <img src="img/img-pattern/img1644.jpg" alt="" />
			</div>
			<p>Редактор документов получает доступ к встроенным изображениям только через интерфейс, определенный в абстрактном классе Graphic. ImageProxy - это класс для представления изображений, создаваемых по требованию. В ImageProxy хранится имя файла, играющее роль ссылки на изображение, которое находится на диске. Имя файла передается конструктору класса ImageProxy.</p>
			<p>В объекте ImageProxy находятся также ограничивающий прямоугольник	изображения и ссылка на экземпляр реального объекта Image. Ссылка остается	недействительной, пока заместитель не инстанцирует реальное изображение.	Операцией Draw гарантируется, что изображение будет создано до того, как заместитель переадресует ему запрос. Операция Get Extent переадресует запрос	изображению, только если оно уже инстанцировано; в противном случае ImageProxy	возвращает размеры, которые хранит сам.</p>
			<h4>Применимость</h4>
			<p>Паттерн заместитель применим во всех случаях, когда возникает необходимость сослаться на объект более изощренно, чем это возможно, если использовать
			простой указатель. Вот несколько типичных ситуаций, где заместитель оказывается полезным:</p>
			<ul>
				<li>а удаленный заместитель предоставляет локального представителя вместо	объекта, находящегося в другом адресном пространстве. В системе NEXTSTEP	[Add94] для этой цели применяется класс NXProxy. Заместителя такого	рода Джеймс Коплиен [Сор92] называет «послом»;</li>
				<li>а виртуальный заместитель создает «тяжелые» объекты по требованию. Примером может служить класс ImageProxy, описанный в разделе «Мотивация»;</li>
				<li>а защищающий заместитель контролирует доступ к исходному объекту. Такие заместители полезны, когда для разных объектов определены различные права доступа. Например, в операционной системе Choices [CIRM93]объекты Kernel Proxy ограничивают права доступа к объектам операционной системы;</li>
				<li>а «умная» ссылка - это замена обычного указателя. Она позволяет выполнить	дополнительные действия при доступе к объекту. К типичным применениям такой ссылки можно отнести:
					<ul>
						<li>подсчет числа ссылок на реальный объект, с тем чтобы занимаемую им память можно было освободить автоматически, когда не останется ни одной ссылки (такие ссылки называют еще «умными» указателями [Ede92]);</li>
						<li>загрузку объекта в память при первом обращении к нему;</li>
						<li>проверку и установку блокировки на реальный объект при обращении к нему, чтобы никакой другой объект не смог в это время изменить его.</li>
					</ul>
				</li>
			</ul>
			<h4>Структура</h4>
			<div class="wrap-image">
			  <img src="img/img-pattern/img1651.jpg" alt="" />
			</div>
			<p>Вот как может выглядеть диаграмма объектов для структуры с заместителем
			во время выполнения.</p>
			<div class="wrap-image">
			  <img src="img/img-pattern/img1660.jpg" alt="" />
			</div>
			<h4>Участники</h4>
			<p>Proxy (imageProxy) - заместитель:</p>
			
				<ul>
					<li>хранит ссылку, которая позволяет заместителю обратиться к реальному	субъекту. Объект класса Proxy может обращаться к объекту класса	Subj ect, если интерфейсы классов RealSubj ect и Subj ect одинаковы;</li>
					<li>предоставляет интерфейс, идентичный интерфейсу Subj ect, так что заместитель всегда может быть подставлен вместо реального субъекта;</li>
					<li>контролирует доступ к реальному субъекту и может отвечать за его создание и удаление;</li>
					<li>прочие обязанности зависят от вида заместителя:</li>
					<li>удаленный заместитель отвечает за кодирование запроса и его аргументов и отправление закодированного запроса реальному субъекту в другом адресном пространстве;</li>
					<li>виртуальный заместитель может кэшировать дополнительную информацию о реальном субъекте, чтобы отложить его создание. Например,	класс ImageProxy из раздела «Мотивация» кэширует размеры реального изображения;</li>
					<li>защищающий заместитель проверяет, имеет ли вызывающий объект необходимые для выполнения запроса права;</li>
				</ul>
				<p>a Subject (Graphic) субъект:</p>
				<ul>
					<li>определяет общий для RealSubject и Proxy интерфейс, так что класс	Proxy можно использовать везде, где ожидается RealSubject;</li>
				</ul>
				<p>a RealSubject (Image) реальный субъект:</p>
				<ul>
					<li>определяет реальный объект, представленный заместителем.</li>
				</ul>
			
			<h4>Отношения</h4>
			<p>Proxy при необходимости переадресует запросы объекту RealSubject. Детали зависят от вида заместителя.</p>
			<h4>Результаты</h4>
			<p>С помощью паттерна заместитель при доступе к объекту вводится дополнительный уровень косвенности. У этого подхода есть много вариантов в зависимости от вида заместителя:</p>
			<ul>
				<li>а удаленный заместитель может скрыть тот факт, что объект находится в другом адресном пространстве;</li>
				<li>а виртуальный заместитель может выполнять оптимизацию, например создание объекта по требованию;</li>
				<li>а защищающий заместитель и «умная» ссылка позволяют решать дополнительные задачи при доступе к объекту.</li>
			</ul>
			<p>Есть еще одна оптимизация, которую паттерн заместитель иногда скрывает	от клиента. Она называется копированием при записи (copy-on-write) и имеет много общего с созданием объекта по требованию. Копирование большого и сложного объекта - очень дорогая операция. Если копия не модифицировалась, то нет	смысла эту цену платить. Если отложить процесс копирования, применив заместитель, то можно быть уверенным, что эта операция произойдет только тогда, когда он действительно был изменен.</p>
			<p>Чтобы во время записи можно было копировать, необходимо подсчитывать	ссылки на субъект. Копирование заместителя просто увеличивает счетчик ссылок. И только тогда, когда клиент запрашивает операцию, изменяющую субъект,	заместитель действительно выполняет копирование. Одновременно заместитель	должен уменьшить счетчик ссылок. Когда счетчик ссылок становится равным	нулю, субъект уничтожается.</p>
			<p>Копирование при записи может существенно уменьшить плату за копирование «тяжелых» субъектов.<p>
			<h4>Реализация</h4>
			<p>При реализации паттерна заместитель можно использовать следующие возможности языка:</p>
			<p>а перегрузку оператора доступа к членам в C++. Язык C++ поддерживает перегрузку оператора доступа к членам класса ->. Это позволяет производить дополнительные действия при любом разыменовании указателя на объект. Для реализации некоторых видов заместителей это оказывается полезно, поскольку заместитель ведет себя аналогично указателю.</p>
			<p>В следующем примере показано, как воспользоваться данным приемом для	реализации виртуального заместителя imagePtr:</p>
			<ul>
				<li>
					<pre>
						class Image;
						extern Image* LoadAnImageFile( const char*);
						// внешняя функция
						class ImagePtr {
						&nbsp;&nbsp;public:
						&nbsp;&nbsp;ImagePtr (const char* imageFile);
						&nbsp;&nbsp;virtual -ImagePtr ();
						&nbsp;&nbsp;virtual Image* operator-> () ;
						&nbsp;&nbsp;virtual Image& operator* ( ) ;
						&nbsp;&nbsp;private:
						&nbsp;&nbsp;Image* Loadlmage ( ) ;
						&nbsp;&nbsp;private:
						&nbsp;&nbsp;Image* _image;
						&nbsp;&nbsp;const char* _imageFile;
						};
						ImagePtr::ImagePtr (const char* theImageFile)
						_imageFile = theImageFile;
						_image = 0;
						}
						Image* ImagePtr::LoadImage () {
						&nbsp;&nbsp;if (_image ==0) {
						&nbsp;&nbsp;_image = LoadAnlmageFile(_imageFile);
						}
						return _image;
						}
					</pre>
					<p>Перегруженные операторы -> и * используют операцию Loadlmage для возврата клиенту изображения, хранящегося в переменной _image (при необходимости загрузив его):</p>
					<pre>
						Image* ImagePtr::operator-> () {
						&nbsp;&nbsp;return Loadlmage();
						}
						Image& ImagePtr::operator* () {
						&nbsp;&nbsp;return *LoadImage();
						}
					</pre>
					<p>Такой подход позволяет вызывать операции объекта Image через объекты ImagePtr, не заботясь о том, что они не являются частью интерфейса данного класса:</p>
					<pre>
						ImagePtr image = ImagePtr("anlmageFileName");
						image->Draw( Point (50, 100));
						// (image.operator->())->Draw(Point(50, 100))
					</pre>
					<p>Обратите внимание, что заместитель изображения ведет себя подобно указателю, но не объявлен как указатель на Image. Это означает, что использовать его в точности как настоящий указатель на Image нельзя. Поэтому при таком подходе клиентам следует трактовать объекты Image и ImagePtr поразному.<p>
					<p>Перегрузка оператора доступа - лучшее решение далеко не для всех видов	заместителей. Некоторым из них должно быть точно известно, какая операция вызывается, а в таких случаях перегрузка оператора доступа не работает.	Рассмотрим пример виртуального заместителя, обсуждавшийся в разделе	«Мотивация». Изображение нужно загружать в точно определенное время - при вызове операции Draw, а не при каждом обращении к нему. Перегрузка оператора доступа не позволяет различить подобные случаи. В такой	ситуации придется вручную реализовать каждую операцию заместителя,	переадресующую запрос субъекту.</p>
					<p>Обычно все эти операции очень похожи друг на друга, как видно из примера кода в одноименном разделе. Они проверяют, что запрос корректен, что	объект-адресат существует и т.д., а потом уже перенаправляют ему запрос. Писать этот код снова и снова надоедает. Поэтому нередко для его aвтoмa^ тической генерации используют препроцессор;</p>
				</li>
				<li>
					<p>а метод doesNotUnderstand в Smalltalk. В языке Smalltalk есть возможность, позволяющая автоматически поддержать переадресацию запросов. При отправлении клиентом сообщения, для которого у получателя нет соответствующего метода, Smalltalk вызывает метод doesNotUnderstand: aMessage.	Заместитель может переопределить doesNotUnderstand так, что сообщение будет переадресовано субъекту.</p>
					<p>Дабы гарантировать, что запрос будет перенаправлен субъекту, а не просто	тихо поглощен заместителем, класс Proxy можно определить так, что он не	станет понимать никаких сообщений. Smalltalk позволяет это сделать, надо	лишь, чтобы у Proxy не было суперкласса1.</p>
					<p>Главный недостаток метода doesNotUnderstand: в том, что в большинстве Smalltalk-систем имеется несколько специальных сообщений, обрабатываемых непосредственно виртуальной машиной, а в этом случае стандартный механизм поиска методов обходится. Правда, единственной такой	операцией, написанной в классе Ob j ect (следовательно, могущей затронуть	заместителей), является тождество ==.</p>
					<p>Если вы собираетесь применять doesNotUnderstand: для реализация	заместителя, то должны как-то решить вышеописанную проблему. Нельзя	же ожидать, что совпадение заместителей - это то же самое, что и совпадение реальных субъектов. К сожалению, doesNotUnderstand: изначально	создавался для обработки ошибок, а не для построения заместителей, поэтому его быстродействие оставляет желать лучшего;</p>
				</li>
				<li>
					<p>а заместителю не всегда должен быть известен тип реального объекта. Если	класс Proxy может работать с субъектом только через его абстрактный интерфейс, то не нужно создавать Proxy для каждого класса реального субъекта Real Sub j ect; заместитель может обращаться к любому из них единообразно. Но если заместитель должен инстанцировать реальных субъектов	(как обстоит дело в случае виртуальных заместителей), то знание конкретного класса обязательно.</p>
				</li>
			</ul>
			<p>К проблемам реализации можно отнести и решение вопроса о том, как обращаться к еще не инстанцированному субъекту. Некоторые заместители должны	обращаться к своим субъектам вне зависимости от того, где они находятся - диске или в памяти. Это означает, что нужно использовать какую-то форму не зависящих от адресного пространства идентификаторов объектов. В разделе «Мотивация» для этой цели использовалось имя файла.</p>
			<h4>Пример кода</h4>
			<p>В коде реализовано два вида заместителей: виртуальный, описанный в разделе «Мотивация», и реализованный с помощью метода doesNotUnderstand:</p>
			<p>виртуальный заместитель. В классе Graphic определен интерфейс для графических объектов:</p>
			<ul>
				<li>
					<pre>
						class Graphic {
						&nbsp;&nbsp;public:
						&nbsp;&nbsp;virtual -Graphic();
						&nbsp;&nbsp;virtual void Draw(const Point& at) = 0;
						&nbsp;&nbsp;virtual void HandleMouse (Event& event) = 0;
						&nbsp;&nbsp;virtual const Point& GetExtent() = 0;
						&nbsp;&nbsp;virtual void Load(istream& from) = 0;
						&nbsp;&nbsp;virtual void Save(ostream& to) = 0;
						&nbsp;&nbsp;protected:
						&nbsp;&nbsp;Graphic();
						};
					</pre>
					<p>Класс Image реализует интерфейс Graphic для отображения файлов изображений. В нем замещена операция HandleMouse, посредством которой пользователь может интерактивно изменять размер изображения:</p>
					<pre>
						class Image : public Graphic {
						&nbsp;&nbsp;public:
						&nbsp;&nbsp;Image(const char* file); // загрузка изображения из файла
						&nbsp;&nbsp;virtual ~Image();
						&nbsp;&nbsp;virtual void Draw(const Point& at);
						&nbsp;&nbsp;virtual void HandleMouse(Event& event);
						&nbsp;&nbsp;virtual const Point& GetExtent();
						&nbsp;&nbsp;virtual void Load(istream& from);
						&nbsp;&nbsp;virtual void Save(ostream& to);
						&nbsp;&nbsp;private:
						&nbsp;&nbsp;// ...
						};
					</pre>
					<p>Класс imageProxy имеет тот же интерфейс, что и Image:</p>
					<pre>
						class ImageProxy : public Graphic {
						&nbsp;&nbsp;public:
						&nbsp;&nbsp;ImageProxy(const char* imageFile);
						&nbsp;&nbsp;virtual ~ImageProxy();
						&nbsp;&nbsp;virtual void Draw(const Point& at);
						&nbsp;&nbsp;virtual void HandleMouse(Event& event);
						&nbsp;&nbsp;virtual const Points GetExtent();
						&nbsp;&nbsp;virtual void Load(istream& from);
						&nbsp;&nbsp;virtual void Save(ostream& to);
						&nbsp;&nbsp;protected:
						&nbsp;&nbsp;Image* GetlmageO;
						&nbsp;&nbsp;private:
						&nbsp;&nbsp;Image* _image;
						&nbsp;&nbsp;Point _extent;
						&nbsp;&nbsp;char* _fileName;
						};
					</pre>
					<p>Конструктор сохраняет локальную копию имени файла, в котором хранится изображение, и инициализирует члены _extent и _image:</p>
					<pre>
						ImageProxy::ImageProxy (const char* fileName) {
						&nbsp;&nbsp;_fileName = strdup(fileName) ;
						&nbsp;&nbsp;_extent = Point::Zero; // размеры пока не известны
						&nbsp;&nbsp;_image = 0;
						}
						Image* ImageProxy::GetImage () {
						&nbsp;&nbsp;if (_image ==0) {
						&nbsp;&nbsp;_image = new Image(_fileName );
						}
						&nbsp;&nbsp;return _image;
						}
					</pre>
					<p>Реализация операции GetExtent возвращает кэшированный размер, если	это возможно. В противном случае изображение загружается из файла. Операция Draw загружает изображение, a HandleMouse перенаправляет событие реальному изображению:</p>
					<pre>
						const Point& ImageProxy::GetExtent () {
						&nbsp;&nbsp;if (_extent == Point::Zero) {
						&nbsp;&nbsp;_extent = GetImage()->GetExtent () ;
						}
						&nbsp;&nbsp;return _extent;
						}
						
						void ImageProxy :: Draw (const Point& at) {
						&nbsp;&nbsp;Get Image () ->Draw(at) ;
						}
						void ImageProxy::HandleMouse (Event& event) {
						&nbsp;&nbsp;Getlmage()->HandleMouse(event);
						}
					</pre>
					<p>Операция Save записывает кэшированный размер изображения и имя файла в поток, a Load считывает эту информацию и инициализирует соответствующие члены:</p>
					<pre>
						void ImageProxy::Save (ostream& to) {
						&nbsp;&nbsp;to « _extent « _fileName;
						}
						void ImageProxy::Load (istream& from) {
						&nbsp;&nbsp;from » _extent » _fileName;
						}
					</pre>
					<p>Наконец, предположим, что есть класс Text Document для представления	документа, который может содержать объекты класса Graphic:<p>
					<pre>
						class TextDocument {
						&nbsp;&nbsp;public:
						&nbsp;&nbsp;TextDocument();
						&nbsp;&nbsp;void Insert(Graphic*);
						&nbsp;&nbsp;// . . .
						};
					</pre>
					<p>Мы можем вставить объект ImageProxy в документ следующим образом:</p>
					<pre>
						TextDocument* text = new TextDocument;
						// ...
						text->Insert(new ImageProxy("anlmageFileName"));
					</pre>
				</li>
				<li>
					<p>заместители, использующие метод doesNotUnderstand. В языке Smalltalk можно создавать обобщенных заместителей, определяя классы, для которых нет суперкласса1, а в них - метод doesNotUnderstand: для обработки сообщений. 	В показанном ниже фрагменте предполагается, что у заместителя есть метод realSubject, возвращающий связанный с ним реальный субъект. Прииспользовании ImageProxy этот метод должен был бы проверить, созданли объект Image, при необходимости создать его и затем вернуть. Для обработки перехваченного сообщения, которое было адресовано реальномусубъекту, используется метод perf orm: withArguments:</p>
					<pre>
						doesNotUnderstand: aMessage
						self realSubject
						perform: aMessage selector
						withArguments: aMessage arguments
					</pre>
					<p>Аргументом doesNotUnderstand: является экземпляр класса Message,	представляющий сообщение, не понятое заместителем. Таким образом, при	ответе на любое сообщение заместитель сначала проверяет, что реальный	субъект существует, а потом уже переадресует ему сообщение.</p>
					<p>Одно из преимуществ метода doesNotUnderstand: - он способен выполнить произвольную обработку. Например, можно было бы создать защищающего заместителя, определив набор legalMessages-сообщений, которые	следует принимать, и снабдив заместителя следующим методом:</p>
					<pre>
						doesNotUnderstand: aMessage
						(legalMessages includes: aMessage selector)
						ifTrue: [self realSubject
						perform: aMessage selector
						withArguments: aMessage arguments]
						ifFalse: [self error: 'Illegal operator']
					</pre>
					<p>Прежде чем переадресовать сообщение реальному субъекту, указанный метод проверяет, что оно допустимо. Если это не так, doesNotUnderstand: посылает сообщение error: самому себе, что приведет к зацикливанию, если в заместителе не определен метод error:. Следовательно, определение error: должно быть скопировано из класса Object вместе со всеми методами, которые в нем используются.</p>
					<p>Практически для любого класса Object является суперклассом самого верхнего уровня. Поэтому выражение «нет суперкласса» означает то же самое, что «Object не является суперклассом».<p>
				</li>
			</ul>
			</div>
		</section>
	</main>
	<footer>
		<div class="container">
			<p>&#169; Copyright 2016 &nbsp; <a href="#">#HardhatsTeam</a></p>
		</div>
	</footer>	
</body>
</html>