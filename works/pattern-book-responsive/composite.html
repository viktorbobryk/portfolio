<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta name="description" content="Object-Oriented Software" />
	<meta name="keywords" content="Design, Patterns, Elements, Reusable, Object-Oriented, Software" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Composite Page</title> <!-- !!! Page name !!! -->
	<link rel="stylesheet" href="css/reset.css" />
	<link rel="stylesheet" href="css/style.css" />
</head>
<body>
	<span class="layout-indicator"></span>
	<header class="header-menu">
		<div class="top-wrap">
			<div class="container">
				<nav>
					<ul>
						<li><a href="adapter.html">Паттерн Adapter</a></li>
						<li><a href="bridge.html">Паттерн Bridge</a></li>
						<li><a href="composite.html" class="active">Паттерн Composite</a></li><!-- !!! link MUST have .active class on corresponding page !!! -->
						<li><a href="decorator.html">Паттерн Decorator</a></li> 
						<li><a href="facade.html">Паттерн Facade</a></li>
						<li><a href="flyweight.html">Паттерн Flyweight</a></li>
						<li><a href="proxy.html">Паттерн Proxy</a></li>
					</ul>
				</nav>
			</div>
		</div>
		<span class="arrow-down arrow-menu">&nbsp;</span>
	</header>
	<main>
		<section id="promo" class="promo-section composite-promo">
		<div class="overlay"></div>
			<div class="container">
				<div class="titles-wrapper">
						<h1>Паттерн Composite</h1>
				</div>
			</div>
		</section>
		<section class="content-section">
			<div class="container">
				<h4>Название и классификация паттерна</h4>
				<p>Компоновщик - паттерн, структурирующий объекты.</p>
				<h4>Назначение</h4>
				<p>Компонует объекты в древовидные структуры для представления иерархий часть-целое.Позволяет клиентам единообразно трактовать индивидуальные и составные объекты.</p>
				<h4>Мотивация</h4>
				<p>Такие приложения, как графические редакторы и редакторы электрических схем, позволяют пользователям строить сложные диаграммы из более простых компонентов. Проектировщик может сгруппировать мелкие компоненты для формирования более крупных,которые, в свою очередь, могут стать основой для создания еще более крупных. В простой реализации допустимо было бы определитьклассы графических примитивов, например текста и линий, а также классы, выступающие в роли контейнеров для этих примитивов.</p>
				<p>Но у такого решения есть существенный недостаток. Программа, в которой эти классы используются,должна по-разному обращаться с примитивами и контейнерами, хотя пользователь чаще всего работает с ними единообразно.Необходимость различать эти объекты усложняет приложение. Паттерн компоновщик описывает, как можно применить рекурсивную композицию таким образом, что клиенту не придется проводить различие между простыми и составными объектами.</p>
				<div class="wrap-image">
					<img src="img/img-pattern/image11.jpg" alt="" />
				</div>
				<p class="paragraph-three-column">>Ключом к паттерну компоновщик является абстрактный класс, который представляет <i>одновременно и примитивы</i>, и контейнеры.В графической системе этот класс может называться Graphic. В нем объявлены операции, специфичные для каждого вида графического объекта (такие как Draw) и общие для всех составных объектов, например операции для доступа и управления потомками.Подклассы Line, Rectangle и Text (см. диаграмму выше) определяют примитивные графические объекты.В них операция Draw реализована соответственно для рисования прямых, прямоугольников и текста. Поскольку у примитивныхобъектов нет потомков, то ни один из этих подклассов не реализует операции,относящиеся к управлению потомками.</p>
				<p>Класс Picture определяет агрегат, состоящий из объектов Graphic. Реализованная в нем операция Draw вызывает одноименную функцию для каждого потомка, а операции для работы с потомками уже не пусты. Поскольку интерфейс класса Picture соответствует интерфейсу Graphic, то в состав объекта Picture могут входить и другие такие же объекты.</p>
				<p>Ниже на диаграмме показана типичная структура составного объекта,   рекурсивно скомпонованного из объектов класса Graphic.</p>
				<div class="wrap-image">
					<img src="img/img-pattern/image12.jpg" alt="" />
				</div>
				<h4>Применимость</h4>
				<p>Используйте паттерн компоновщик, когда:</p>
					<ul>
						<li>нужно представить иерархию объектов вида часть-целое;</li>
						<li>хотите, чтобы клиенты единообразно трактовали составные и индивидуальные объекты.<li>
					</ul>
				<h4>Структура</h4>
				<div class="wrap-image">
					<img src="img/img-pattern/image13.jpg" alt="" />
				</div>
				<p>Структура типичного составного объекта могла бы выглядеть так:</p>
				<div class="wrap-image">
					<img src="img/img-pattern/image14.jpg" alt="" />
			    </div>
				<h4>Участники</h4>
				<ul>
					<li>Component (Graphic) - компонент:
						<ul>
							<li>объявляет интерфейс для компонуемых объектов;</li>
							<li>предоставляет подходящую реализацию операций по умолчанию, общую для всех классов;</li>
							<li>объявляет интерфейс для доступа к потомкам и управления ими;</li>
							<li>определяет интерфейс для доступа к родителю компонента в рекурсивной структуре и при необходимости реализует его. Описанная возможность необязательна;</li>
						</ul>
					</li>
					<li>Leuf (Rectangle, Line, Text, и т.п.) - лист:
						<ul>
							<li>представляет листовые узлы композиции и не имеет потомков;</li>
							<li>определяет поведение примитивных объектов в композиции;</li>
						</ul>
					</li>
					<li>Composite (Picture) - составной объект:
						<ul>
							<li>определяет поведение компонентов, у которых есть потомки;</li>
							<li>хранит компоненты-потомки;</li>
							<li>реализует относящиеся к управлению потомками операции в интерфейсе клaсса Component;</li>
						</ul>
					</li>
					<li>Client - клиент:
						<ul>
							<li>манипулирует объектами композиции через интерфейс Component.</li>
						</ul>
					</li>
				</ul>
				<h4>Отношения</h4>
				<p>Клиенты используют интерфейс класса Component для взаимодействия с объектами в составной структуре.Если получателем запроса является листовый объект Leaf, то он и обрабатывает запрос. Когда же получателем является составной объект Composite, то обычно он перенаправляет запрос своим потомкам, возможно, выполняя некоторые дополнительные операции до или после перенаправления.</p>
				<h4>Результаты</h4>
				<p>Паттерн компоновщик:</p>
				<ul>
					<li><i>определяет иерархии классов, состоящие из примитивных и составных объектов.</i>
						Из примитивных объектов можно составлять более сложные, которые, в свою очередь, участвуют в более сложных композициях и так далее. Любой клиент, ожидающий примитивного объекта, может работать и с составным;</li>
					<li><i>упрощает архитектуру клиента.</i>
						Клиенты могут единообразно работать с индивидуальными и объектами и с составными.Обычно клиенту неизвестно, взаимодействует ли он с листовым или составным объектом. Это упрощает код клиента, поскольку нет необходимости писать функции, ветвящиеся в зависимости от того,с объектом какого класса они работают;</li>
					<li><i>облегчает добавление новых видов компонентов.</i>
						Новые подклассы классов Composite или Leaf будут автоматически работать с уже существующими структурами и клиентским кодом. Изменять клиента при добавлении новых компонентов не нужно</li>
					<li><i>способствует созданию общего дизайна.</i>
						Однако такая простота добавления новых компонентов имеет и своиотрицательные стороны: становится трудно наложить ограничения на то, какие объекты могут входить в состав композиции.Иногда желательно, чтобы составной объект мог включать только определенные виды компонентов. Паттерн компоновщик непозволяет воспользоваться для реализации таких ограничений статической системой типов.Вместо этого следует проводить проверки во время выполнения.</li>
				</ul>
				<h4>Реализация</h4>
				<p>При реализации паттерна компоновщик приходится рассматривать много вопросов:</p>
				<ul>
					<li><i>явные ссылки на родителей.</i>
						Хранение в компоненте ссылки на своего родителя может упростить обход структуры.Наличие такой ссылки облегчает передвижение вверх по структуре и удаление компонента.Кроме того, ссылки на родителей помогают поддержать паттерн цепочка обязанностей.Обычно ссылку на родителя определяют в При наличии ссылки на родителя важно поддерживать следующий инвариант: если некоторый объект в составной структуре ссылается на другой составной объект как на своего родителя, то для последнего первый является  потомком. Простейший способ гарантировать соблюдение этого условия - изменять родителя компонента только тогда, когда он добавляется или удаляется из составного объекта. Если это удается один раз реализовать в операциях Add и Remove, то реализация будет унаследована всеми подклассами и, значит, инвариант будет поддерживаться автоматически;</li>
					<li><i>разделение компонентов.</i>
						Часто бывает полезно разделять компоненты, например для уменьшения объема занимаемой памяти.Но если у компонента может быть более одного родителя, то разделение становится проблемой.Возможное решение - позволить компонентам хранить ссылки на нескольких родителей. Однако в таком случае при распространении запроса по структуре могут возникнуть неоднозначности. Паттерн приспособленец показывает, как следует изменить дизайн, чтобы вовсе отказаться от хранения родителей. Работает он в тех случаях, когда потомки могут не посылать сообщений своим родителям, вынеся за свои границы часть внутреннего состояния;</li>
					<li><i>максимизация интерфейса класса Component.</i>
						Одна из целей паттерна компоновщик - избавить клиентов от необходимости знать работают ли они с листовым или составным объектом. Для достижения этой цели класс Component должен сделать как можно больше операций общими для классов Composite и Leaf. Обычно класс Component предоставляет для этих операций реализации по умолчанию, а подклассы Composite и Leaf замещают их. Однако иногда эта цель вступает в конфликт с принципом проектирования иерархии классов, согласно которому класс должен определять только логичные для всех его подклассах операции. Класс Component поддерживает много операций,не имеющих смысла для класса Leaf. Как же тогда предоставить для них реализацию по умолчанию?Иногда, проявив изобретательность, удается перенести в класс Component операцию, которая, на первый взгляд,имеет смысл только для составных  объектов. Например, интерфейс для доступа к потомкам является фундаментальной частью класса Composite, но вовсе не обязательно класса Leaf.Однако если рассматривать Leaf как Component,у которого никогда не бывает потомков, то мы можем определить в классе Component операцию доступа к потомкам как никогда не возвращающую потомков. Тогда подклассы Leaf могут использовать эту реализацию по умолчанию, а в подклассах Composite она будет переопределена, чтобы возвращать потомков.Операции для управления потомками довольно хлопотны, мы обсудим их в следующем разделе.</li>
					<li><i>объявление операций для управления потомками.</i>
						Хотя в классе Composite реализованы операции Add и Remove для добавления и удаления потомков,но для паттерна компоновщик важно, в каких классах эти операции объявлены. Надо ли объявлять их в классе Component и тем самым делать доступными в Leaf, или их следует объявить и определить только в классе Composite и его подклассах? Решая этот вопрос, мы должны выбирать между безопасностью и прозрачностью:
						<ul>
							<li>если определить интерфейс для управления потомками в корне иерархииклассов, то мы добиваемся прозрачности,так как все компоненты удается трактовать единообразно. Однако расплачиваться приходится безопасностью,поскольку клиент может попытаться выполнить бессмысленное действие, например добавить или удалить;</li>
							<li>если управление потомками сделать частью класса Composite, то безопасность удастся обеспечить ведь любая попытка добавить или удалить объекты из листьев в статически типизированном языке вроде C++ будет перехвачена на этапе компиляции. Но прозрачность мы утрачиваем,ибо у листовых и составных объектов оказываются разные интерфейсы.</li>
						</ul>
						В паттерне компоновщик мы придаем особое значение прозрачности, а не безопасности. Если для вас важнее безопасность,будьте готовы к тому, что иногда вы можете потерять информацию о типе и придется преобразовывать компонентк типу составного объекта. Как это сделать, не прибегая к небезопасным приведениям типов? Можно, например, объявить в классе Component операцию Composite* GetComposite (). Класс Component реализует ее по умолчанию, возвращая нулевой указатель. А в классе Composite эта операция переопределена и возвращает указатель this на сам объект</li>
				</ul>
				<pre>
					class Composite;
					class Component {
					&nbsp;&nbsp;public:
					&nbsp;&nbsp;//...
					&nbsp;&nbsp;virtual Composite* GetComposite() { return 0; }
					};
					class Composite : public Component {
					&nbsp;&nbsp;public:
					&nbsp;&nbsp;void Add(Component*);
					&nbsp;&nbsp;// ...
					&nbsp;&nbsp;virtual Composite* GetComposite(} { return this; }
					};
					&nbsp;&nbsp;class Leaf : public Component {
					&nbsp;&nbsp;// ...
					};
				</pre>
				<p>Благодаря операции Get Composite можно спросить у компонента, является ли он составным.К возвращаемому этой операцией составному объекту допустимо безопасно применять операции Add и Remove:</p>
				<pre>
					Composite* aComposite = new Composite;
					Leaf* aLeaf = new Leaf; 
					
					Component * aComponent;
					Composite* test;
					
					aComponent = aComposite;
					if (test = aComponent->GetComposite()) {
					&nbsp;&nbsp;test->Add(new Leaf);
					}
					
					aComponent = aLeaf;
					if (test = aComponent->GetComposite()) {
					&nbsp;&nbsp;test->Add(new Leaf); // не добавит лист
					} 
				</pre>
				<p>Аналогичные проверки на принадлежность классу Composite в C++ выполняют и с помощью оператора dynamic_cast.</p>
				<p>Разумеется, при таком подходе мы не обращаемся со всеми компонентами единообразно, что плохо.Снова приходится проверять тип, перед тем как предпринять то или иное действие.</p>
				<p>Единственный способ обеспечить прозрачность - это включить в классComponent реализации операций Add и Remove по умолчанию Но появится новая проблема: нельзя реализовать Component : : Add так, чтобы она никогда не приводила к ошибке. Можно, конечно, сделать данную операцию пустой, но тогда нарушается важное проектное ограничение; попытка добавить что то в листовой обект, скорее всего, свидетельствует об ошибке. Допустимо было бы заставить ее удалять свой аргумент, но клиент может быть не рассчитанным на это.</p>
				<p>Обычно лучшим решением является такая реализация Add и Remove по умолчанию, при которой они завершаются с ошибкой(возможно, возбуждая исключение), если компоненту не разрешено иметь потомков (для Add) или аргумент не является чьим-либо потомком (для Remove).Другая возможность - слегка изменить семантику операции «удаления».Если компонент хранит ссылку на родителя, то можно было бы считать, что Component: : Remove удаляет самого себя. Но для операции Add по-прежнему нет разумной интерпретации:</p>
				<ul>
					<li><i>должен ли Component реализовывать список компонентов.</i>
						Может возникнуть желание определить множество потомков в виде переменной экземпляра класса Component, в котором объявлены операции доступа и управления потомками.Но размещение указателя на потомков в базовом классе приводит к непроизводительному расходу памяти во всех листовых узлах, хотя у листа потомков быть не может. Такой прием можно применить, только если в структуре не слишком много потомков;</li>
					<li><i>упорядочение потомков.</i>
						Во многих случаях порядок следования потомков составного объекта важен. В рассмотренном выше примере класса Graphic под порядком может пониматься Z-порядок расположения потомков. В составных объектах, описывающих деревья синтаксического разбора, составные операторы могут быть экземплярами класса Composite,порядок следования потомков которых отражает семантику программы.Если порядок следования потомков важен, необходимо учитывать его при проектировании интерфейсов доступа и управления потомками. В этом может помочь паттерн итератор;</li>
					<li><i>кэширование для повышения производительности.</i>
						Если приходится часто обходить композицию или производить в ней поиск,то класс Composite может кэшировать информацию об обходе и поиске. Кэшировать разрешается либо полученные результаты, либо только информацию, достаточную для ускорения обхода или поиска.Например, класс Picture из примера, приведенного в разделе «Мотивация», мог бы кэшировать охватывающие прямоугольники своих потомков. При рисовании или выборе эта информация позволила бы пропускать тех потомков, которые не видимы в текущем окне. Любое изменение компонента должно делать кэши всех его родителей недействительными.Наиболее эффективен такой подход в случае, когда ком-понентам известно об их родителях. Поэтому, если вы решите воспользоваться кэшированием, необходимо определить интерфейс, позволяющийуведомить составные объекты о недействительности их кэшей;</li>
					<li><i>кто должен удалять компоненты.</i>
						В языках, где нет сборщика мусора, лучше всего поручить классу Composite удалять своих потомков в момент уничтожения. Исключением из этого правила является случай, когда листовыеобъекты постоянны и; следовательно, могут разделяться; _ •» _</li>
					<li><i>какая структура данных лучше всего подходит для хранения компонентов.</i>
						Составные объекты могут хранить своих потомков в самых разных структурах данных, включая связанные списки,деревья, массивы и хэш-таблицы.Выбор структуры данных определяется, как всегда, эффективностью.Собственно говоря, вовсе не обязательно пользоваться какой-либо из универсальных структур.Иногда в составных объектах каждый потомок представляется отдельной переменной. Правда,для этого каждый подкласс Composite должен реализовывать свой собственный интерфейс управления памятью.См. пример в описании паттерна интерпретатор.</li>
				</ul>
				<h4>Пример кода</h4>
				<p>Такие изделия, как компьютеры и стереокомпоненты, часто имеют иерархическую структуру.Например, в раме монтируются дисковые накопители и плоские электронные платы, к шине подсоединяются различные карты,а корпус содержит раму, шины и т.д. Подобные структуры моделируются с помощью паттерна компоновщик.</p>
				<p>Класс Equipment определяет интерфейс для всех видов аппаратуры в иерархии вида часть-целое:</p>
				<pre>
					class Equipment {
					&nbsp;&nbsp;public:
					&nbsp;&nbsp;virtual -Equipment ( ) ;

					&nbsp;&nbsp;const char* NameO { return _name; }

					&nbsp;&nbsp;virtual Watt Power ();
					&nbsp;&nbsp;virtual Currency NetPrice();
					&nbsp;&nbsp;virtual Currency DiscountPrice ( ) ;
											 
					&nbsp;&nbsp;virtual void Add ( Equipment *);
					&nbsp;&nbsp;virtual void Remove (Equipment*) ;
					&nbsp;&nbsp;virtual Iterator(Equipment*) Createlterator ();
					&nbsp;&nbsp;protected:
					&nbsp;&nbsp;Equipment (const char*);
					&nbsp;&nbsp;private:
					&nbsp;&nbsp;const char* _name;
					};
				</pre>
				<p>В классе Equipment объявлены операции, которые возвращают атрибуты аппаратного блока,например энергопотребление и стоимость. Подклассы реализуют эти операции для конкретных видов оборудования. Класс Equipment объявляет также операцию Createlterator, возвращающую итератор Iterator (см.приложение С) для доступа к отдельным частям. Реализация этой операции по умолчанию возвращает итератор Null Iterator, умеющий обходить только пустое множество.Среди подклассов Equipment могут быть листовые классы, представляющие дисковые накопители, СБИС и переключатели:</p>
				<pre>
					class FloppyDisk : public Equipment {
					public:
					&nbsp;&nbsp;FloppyDisk(const char*);
					&nbsp;&nbsp;virtual -FloppyDisk();
					&nbsp;&nbsp;virtual Watt Power();
					&nbsp;&nbsp;virtual Currency NetPriceO;
					&nbsp;&nbsp;virtual Currency DiscountPrice();
					};
				</pre>
				<p>CompositeEquipment - это базовый класс для оборудования, содержащегодругое оборудование. Одновременно это подкласс класса Equipment:</p>
				<pre>
					class CompositeEquipment : public Equipment {
					public:
					&nbsp;&nbsp;virtual -CompositeEquipment();
						
					&nbsp;&nbsp;virtual Watt Power();
					&nbsp;&nbsp;virtual Currency NetPriceO;
					&nbsp;&nbsp;virtual Currency DiscountPrice();
						
					&nbsp;&nbsp;virtual void Add(Equipment*);
					&nbsp;&nbsp;virtual void Remove(Equipment*);
					&nbsp;&nbsp;virtual Iterator(Equipment*) Createlterator();
						
					protected:
					&nbsp;&nbsp;CompositeEquipment(const char*);
					private:
					&nbsp;&nbsp;List(Equipment*)equipment;
					};
				</pre>
				<p>CompositeEquipment определяет операции для доступа и управления внутренними аппаратными блоками. Операции Add и Remove добавляют и удаляют оборудование из списка, хранящегося в переменной-члене _equipment.Операция Createlterator возвращает итератор (точнее, экземпляр класса List Iterator),который будет обходить этот список.</p>
				<p>Подразумеваемая реализация операции Net Price могла бы использовать Createlterator для суммирования цен на отдельные блоки:</p>
				<pre>
					Currency CompositeEquipment::NetPrice () {
					&nbsp;&nbsp;Iterator(Equipment*) i = Createlterator();
					&nbsp;&nbsp;Currency total = 0;
						
					&nbsp;&nbsp;for (i->First(); !i->IsDone(); i->Next()) {
					&nbsp;&nbsp;total += i->CurrentItem()->NetPrice();
					&nbsp;&nbsp;}
					&nbsp;&nbsp;delete i;
					&nbsp;&nbsp;return total;
					}
				</pre>
				<p>Очень легко забыть об удалении итератора после завершения работы с ним. При обсуждении паттерна итератор рассказано, как защититься от таких ошибок.</p>
				<p>Теперь мы можем представить аппаратный блок 	компьютера в виде подкласса к CompositeEquipment под названием Chassis.Chassis наследует порожденные операции класса CompositeEquipment.</p>
				<pre>
					class Chassis : public CompositeEquipment {
					public:
					&nbsp;&nbsp;Chassis(const char*);
					&nbsp;&nbsp;virtual -Chassis();
						
					&nbsp;&nbsp;virtual Watt Power();
					&nbsp;&nbsp;virtual Currency NetPriceO;
					&nbsp;&nbsp;virtual Currency DiscountPrice();
					};
				</pre>
				<p>Мы можем аналогично определить и другие контейнеры для оборудования,например Cabinet (корпус) и Bus (шина). Этого вполне достаточно для сборки из отдельных блоков довольно простого персонального компьютера:</p>
				<pre>
					Cabinet* cabinet = new Cabinet("PC Cabinet");
					Chassis* chassis = new Chassis("PC Chassis");
					
					cabinet->Add(chassis);
					
					Bus* bus = new Bus("MCA Bus");
					bus->Add(new Card("16Mbs Token Ring"));
					
					chassis->Add(bus);
					chassis->Add(new FloppyDisk("3.Sin Floppy"));
					
					cout « "Полная стоимость равна " « chassis->NetPrice() « endl;
				</pre>
				<h4>Известные применения</h4>
				<p>Примеры паттерна компоновщик можно найти почти во всех объектно-ориентированных системах.Первоначально класс View в схеме модель/вид/контроллер в языке Smalltalk [KP88] был компоновщиком,и почти все библиотеки для построения пользовательских интерфейсов и каркасы проектировались аналогично.Среди них ЕТ++ (со своей библиотекой VObjects [WGM88]) и Interviews (классы Styles [LCI+92], Graphics [VL88] и Glyphs [CL90]). Интересно отметить, что первоначально вид View имел несколько подвидов, то есть он был одновременно и классом Component, и классом Composite. В версии 4.0 языка Smalltalk-80 схема модель/вид/контроллер была пересмотрена, в нее ввели класс Visual-Component, подклассами которого являлись View и CompositeView.</p>
				<p>В каркасе для построения компиляторов RTL, который написан на Smalltalk [JML92],паттерн компоновщик используется очень широко. RTLExpression - это разновидность класса Component для построения деревьев синтаксического разбора. У него есть подклассы, например Binary Expression,потомками которого являются объекты класса RTLExpression.В совокупности эти классы определяют составную структуру для деревьев разбора. RegisterTransf'er - класс Component для промежуточной формы представления программы SSA (Single Static Assignment). Листовые подкласс^ RegisterTransf er определяют различные статические присваивания, например:</p>
				<ul>
					<li>примитивные присваивания, которые выполняют операцию над двумя регистрами и сохраняют результат в третьем;</li>
					<li>присваивание, у которого есть исходный, но нет целевого регистра. Следовательно, регистр используется после возврата из процедуры;</li>
					<li>присваивание, у которого есть целевой, но нет исходного регистра. Это означает, что присваивание регистру происходит перед началом процедуры.</li>
				</ul>
				<p>Подкласс RegisterTransf erSet является примером класса Composite для представления присваиваний, изменяющих сразу несколько регистров.</p>
				<p>Другой пример применения паттерна компоновщик - финансовые программы, когда инвестиционный портфель состоит их нескольких отдельных активов. Можно поддержать сложные агрегаты активов, Јсли реализовать портфель в виде компоновщика, согласованного с интерфейсом каждого актива [ВЕ93].</p>
				<p>Паттерн команда описывает, как можно компоновать и упорядочивать объекты Command с помощью класса компоновщика MacroCommand.</p>
				<h4>Родственные паттерны</h4>
				<p>Отношение компонент-родитель используется в паттерне цепочка обязанностей.</p>
				<p>Паттерн декоратор часто применяется совместно с компоновщиком. Когда декораторы и компоновщики используются вместе, у них обычно бывает общий родительский класс. Поэтому декораторам придется поддержать интерфейс компонентов такими операциями, как Add, Remove и GetChild.</p>
				<p>Паттерн приспособленец позволяет разделять компоненты, но ссылаться на своих родителей они уже не могут.</p>
				<p>Итератор можно использовать для обхода составных объектов.</p>
				<p>Посетитель локализует операции и поведение, которые в противном случае пришлось бы распределять между классами Composite и Leaf.</p>
			</div>
		</section>
	</main>
	<footer>
		<a href="index.html" class="go-home-button">&nbsp;</a>
		<a href="#promo" class="go-top">&nbsp;</a>
		<div class="container">
			<p>&#169; Copyright 2016 &nbsp; <a href="#">#HardhatsTeam</a></p>
		</div>
	</footer>
</body>
</html>