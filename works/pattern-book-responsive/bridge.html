<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta name="description" content="Object-Oriented Software" />
	<meta name="keywords" content="Design, Patterns, Elements, Reusable, Object-Oriented, Software" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Bridge Page</title> <!-- !!! Page name !!! -->
	<link rel="stylesheet" href="css/reset.css" />
	<link rel="stylesheet" href="css/style.css" />
</head>
<body>
	<span class="layout-indicator"></span>
	<header class="header-menu">
		<div class="top-wrap">
			<div class="container">
				<nav>
					<ul>
						<li><a href="adapter.html">Паттерн Adapter</a></li>
						<li><a href="bridge.html" class="active">Паттерн Bridge</a></li><!-- !!! link MUST have .active class on corresponding page !!! -->
						<li><a href="composite.html">Паттерн Composite</a></li>
						<li><a href="decorator.html">Паттерн Decorator</a></li> 
						<li><a href="facade.html">Паттерн Facade</a></li>
						<li><a href="flyweight.html">Паттерн Flyweight</a></li>
						<li><a href="proxy.html">Паттерн Proxy</a></li>
					</ul>
				</nav>
			</div>
		</div>
		<span class="arrow-down arrow-menu">&nbsp;</span>
	</header>
	<main>
		<section id="promo" class="promo-section bridge-promo">
		<div class="overlay"></div>
			<div class="container">
				<div class="titles-wrapper">
						<h1>Паттерн Bridge</h1>
				</div>
			</div>
		</section>
		<section class="content-section">
			<div class="container">
				<h3>Название и классификация паттерна</h3>
				<p>Мост - паттерн, структурирующий объекты.</p>
				<h3>Назначение</h3>
				<p>Отделить абстракцию от ее реализации так, чтобы то и другое можно было изменять независимо.</p>
				<h3>Известен также под именем</h3>
				<p>Handle/Body (описатель/тело).</p>
				<h3>Мотивация</h3>
				<p>Если для некоторой абстракции возможно несколько реализаций, то обычно применяют наследование. Абстрактный класс определяет интерфейс абстракции, а его конкретные подклассы по-разному реализуют его. Но такой подход не всегда обладает достаточной гибкостью. Наследование жестко привязывает реализацию к абстракции, что затрудняет независимую модификацию, расширение и повторное использование абстракции и ее реализации
				</p>
				<p>Рассмотрим реализацию переносимой абстракции окна в библиотеке для разработки пользовательских интерфейсов. Написанные с ее помощью приложения должны работать в разных средах, например под X Window System и Presentation Manager (PM) от компании IBM. С помощью наследования мы могли бы определить абстрактный класс Window и его подклассы XWindow и PMWindow, реализующие интерфейс окна для разных платформ. Но у такого решения есть два недостатка:
				</p>
				<ul>
					<li>
						<p>неудобно распространять абстракцию Window на другие виды окон или новые платформы. Представьте себе подкласс IconWindow, который специализирует абстракцию окна для пиктограмм. Чтобы поддержать пиктограммы на обеих платформах, нам придется реализовать два новых подкласса XlconWindow и PMIconWindow. Более того, по два подкласса необходимо определять для каждого вида окон. А для поддержки третьей платформы придется определять для всех видов окон новый подкласс Window;</p>
						<div class="wrap-image">
							<img src="img/img-pattern/image8.jpg" alt="" />
						</div>
					</li>
					<li>клиентский код становится платформенно-зависимым. При создании окна клиент инстанцирует конкретный класс, имеющий вполне   	определенную реализацию. Например, создавая объект XWindow, мы привязываем абстракцию окна к ее реализации для системы X Window и,
					следовательно, делаем код клиента ориентированным именно на эту оконную систему. Таким образом усложняется перенос клиента на другие платформы. Клиенты должны иметь возможность создавать окно, не привязываясь к конкретной реализации. Только сама реализация окна должна зависеть от платформы, на которой работает приложение. Поэтому в клиентском коде не может быть никаких упоминаний о платформах
					</li>
				</ul>
				<p>С помощью паттерна мост эти проблемы решаются. Абстракция окна и ее реализация помещаются в раздельные иерархии классов. Таким образом, существует одна иерархия для интерфейсов окон (Window, IconWindow, TransientWindow) и другая (с корнем Windowimp) - для платформенно-зависимых реализаций. Так, подкласс XWindowImp предоставляет реализацию в системе X Window System.
				</p>
				<div class="wrap-image">
					 <img src="img/img-pattern/image9.jpg" alt="" />
				</div>
				<p>Все операции подклассов Window реализованы в терминах абстрактных операций из интерфейса Windowimp. Это отделяет абстракцию окна от различных ее платформенно-зависимых реализаций. Отношение между классами Window и Windowimp мы будем называть мостом, поскольку между абстракцией и реалиацией строится мост, и они могут изменяться независимо
				</p>
				<h3>Применимость</h3>
				<p>Используйте паттерн мост, когда:</p>
				<h3>Название и классификация паттерна</h3>
				<p>Мост - паттерн, структурирующий объекты.</p>
				<h3>Назначение</h3>
				<p>Отделить абстракцию от ее реализации так, чтобы то и другое можно было изменять независимо.</p>
				<h3>Известен также под именем</h3>
				<p>Handle/Body (описатель/тело).</p>
				<h3>Мотивация</h3>
				<p>Если для некоторой абстракции возможно несколько 	реализаций, то обычно применяют наследование. Абстрактный класс определяет интерфейс абстракции, а его конкретные подклассы по-разному реализуют его. Но такой подход не всегдаобладает достаточной гибкостью. Наследование жестко привязывает реализацию к абстракции, что затрудняет независимую модификацию, расширение и повторное использование абстракции и ее реализации
				</p>
				<p>Рассмотрим реализацию переносимой абстракции окна в библиотеке для разработки пользовательских интерфейсов.	Написанные с ее помощью приложения должны работать в разных средах, например под X Window System и Presentation	Manager (PM) от компании IBM. С помощью наследования мы могли бы определить абстрактный класс Window и его подклассы XWindow	и PMWindow, реализующие интерфейс окна для разных платформ. Но у такого решения есть два недостатка:
				</p>
				<ul>
					<li>неудобно распространять абстракцию Window на другие виды окон или новые платформы. Представьте себе подкласс IconWindow,	который специализирует абстракцию окна для пиктограмм. Чтобы поддержать пиктограммы на обеих платформах,	нам придется реализовать два новых подкласса XlconWindow и PMIconWindow. Более того, по два подкласса необходимо	определять для каждого вида окон. А для поддержки третьей платформы придется определять для всех видов окон новый подкласс Window;
					<div class="wrap-image">
						<img src="img/img-pattern/image8.jpg" alt="" />
					</div>
					</li>
					<li>клиентский код становится платформенно-зависимым. При создании окна клиент инстанцирует конкретный класс, имеющий вполне   	определенную реализацию. Например, создавая объект XWindow, мы привязываем абстракцию окна к ее реализации для системы X Window и,	следовательно, делаем код клиента ориентированным именно на эту оконную систему. Таким образом усложняется перенос	клиента на другие платформы. Клиенты должны иметь возможность создавать окно, не привязываясь к конкретной реализации.	Только сама реализация окна должна зависеть от платформы, на которой работает приложение. Поэтому в клиентском коде не	может быть никаких упоминаний о платформах
					</li>
				</ul>
				<p>С помощью паттерна мост эти проблемы решаются. Абстракция окна и ее реализация помещаются в раздельные иерархии классов. Таким образом, существует одна иерархия для интерфейсов окон (Window, IconWindow, TransientWindow)и другая (с корнем Windowimp) - для платформенно-зависимых реализаций. Так, подкласс XWindowImp предоставляет реализацию в системе X Window System.
				</p>
				<div class="wrap-image">
					<img src="img/img-pattern/image9.jpg" alt="" />
				</div>
				<p>Все операции подклассов Window реализованы в терминах абстрактных операций из интерфейса Windowimp.Это отделяет абстракцию окна от различных ее платформенно-зависимых реализаций. Отношение между классами Window и Windowimp мы будем называть мостом, поскольку между абстракцией и реалиацией строится мост, и они могут изменяться независимо
				</p>
				<h3>Применимость</h3>
				<p>Используйте паттерн мост, когда:</p>
				<ul>
					<li>хотите избежать постоянной привязки абстракции к реализации. Так, например, бывает, когда реализацию необходимо выбирать во время выполнения программы;
					</li>
					<li>и абстракции, и реализации должны расширяться новыми подклассами.В таком случае паттерн мост позволяеткомбинировать разные абстракции и реализации и изменять их независимо;
					</li>
					<li>о изменения в реализации абстракции не должны сказываться на клиентах,то есть клиентский код не должен перекомпилироваться;
					</li>
					<li>
						<i>(только для C++!)</i>
						вы хотите полностью скрыть от клиентов реализацию абстракции. В C++ представление класса видимо через его нтерфейс;	
					</li>
					<li>число классов начинает быстро расти, как мы видели на первой диаграмме из раздела «Мотивация». Это признак того, что иерархию следует разделить на две части. Для таких иерархий классов Рамбо (Rumbaugh) использует термин «вложенные обобщения» [RBP+91];
					</li>
					<li>вы хотите разделить одну реализацию между несколькими объектами (быть может, применяя подсчет ссылок), и этот факт необходимо скрыть от клиента. Простой пример - это разработанный Джеймсом Коплиеном класс String [Сор92], в котором разные объекты могут разделять одно и то же представление строки (StringRep).
					</li>
				</ul>
				<h3>Структура</h3>
				<div class="wrap-image">
				    <img src="img/img-pattern/image10.jpg" alt="" />
			    </div>
				<h3>Учасники</h3>
				<ul>
					<li>
						<b>Abstraction</b>
						(Window) - абстракция:определяет интерфейс абстракции;хранит ссылку на объект типа Implement or;
					</li>
					<li>
						<b>RefinedAbstraction</b>
						(iconWindow) -   уточненная абстракция: расширяет интерфейс, определенный абстракцией Abstraction;
					</li>
					<li>
						<b>Implementor</b>
						(Windowlmp) - реализатор:определяет интерфейс для классов реализации. Он не обязан точно соответствовать интерфейсу класса Abstraction. На самом деле оба интерфейса могут быть совершенно различны. Обычно интерфейс класса Implementor предоставляет только примитивные операции, а класс Abstraction определяет операции более высокого уровня, базирующие ся на этих примитивах;
					</li>
					<li>
						<b>Concretelmplementor</b>
						(XWindowlmp, PMWindowlmp) - конкретный реализатор: содержит конкретную реализацию интерфейса класса Implementor. 
					</li>
				</ul>
				<h4>Отношения</h4>
				<p>Объект Abstraction перенаправляет своему объекту Implementor запросы клиента.</p>
				<h3>Результаты</h3>
				<p>Результаты применения паттерна мост таковы:</p>
				<ul>
					<li>
						<i>отделение реализации от интерфейса.</i>
						Реализация больше не имеет постоянной привязки к интерфейсу. Реализацию абстракции 	можно конфигурировать во время выполнения. Объект может даже динамически изменять свою реализацию. Разделение классов Abstraction и Implementor устраняет также зависимости от реализации, устанавливаемые на этапе компиляции.Чтобы изменить класс реализации, вовсе не обязательно перекомпилировать класс Abstraction и его клиентов.Это свойство особенно важно, если необходимо обеспечить двоичную совместимость между разными версиями библиотеки классов. Кроме того, такое разделение облегчает разбиение системы на слои и тем самым позволяет улучшить ее структуру. Высокоуровневые части системы должны знать только о классах Abstraction и Implementor
					</li>
					<li><i>повышение степени расширяемости.</i>Можно расширять независимо иерархии классов Abstraction и Implementor;
					</li>
					<li>
						<i>сокрытие деталей реализации от клиентов.</i>
						Клиентов можно изолировать от таких деталей реализации, как разделение	объектов класса Implementor и сопутствующего механизма подсчета ссылок.
					</li>
					<li>
						<i>сокрытие деталей реализации от клиентов.</i>
						Клиентов можно изолировать от таких деталей реализации, как разделение  объектов класса Implementor и сопутствующего механизма подсчета ссылок.
					</li>
				</ul>
				<h3>Реализация</h3>
				<p>Если вы предполагаете применить паттерн мост, то подумайте о таких вопросах реализации:</p>
				<ul>
					<li>
						<i>только один класс Implementor.</i>
						В ситуациях, когда есть только одна реализация, создавать абстрактный класс Implementor
						необязательно. Это вырожденный случай паттерна мост- между классами Abstraction и Implementor существует взаимно-однозначное соответствие.Тем не менее разделение все же полезно, если нужно, чтобы изменение реализации класса не отражалось на существующих клиентах (должно быть достаточно заново скомпоновать программу, не перекомпилируя клиентский код). Для описания такого разделения Каролан (Carolan) [Car89] употребляет сочетание «чеширский кот». В C++ интерфейс класса Implementor можно определить в закрытом заголовочном файле, который не передается клиентам. Это позволяет полностью скрыть реализацию класса от клиентов; 
					</li>
					<li>
						<i>создание правильного объекта Implementor.</i>
						Как, когда и где принимается решение о том, какой из нескольких классов
						Implementor инстанцировать? Если у класса Abstraction есть информация о конкретных классах Concretelmplementor, то он может инстанцировать один из них в своем конструкторе; какой именно - зависит от переданных конструктору параметров. Так, если класс коллекции поддерживает несколько реализаций, то решение можно принять в зависимости от размера коллекции. Для небольших коллекций применяется реализация в виде связанного списка, для больших - в виде хэшированных таблиц. Другой подход - заранее выбрать реализацию по умолчанию, а позже изменять ее в соответствии с тем, как она используется. Например, если число элементов в коллекции становится больше некоторой условной величины, то мы переключаемся с одной реализации на другую, более эффективную.Можно также делегировать решение другому объекту.В примере с иерархиями Window/Windowlmp уместно было бы ввести фабричный объект (см. паттерн абстрактная фабрика), единственная задача которого - инкапсулировать платформенную специфику. Фабрика обладает информацией, объекты Windowlmp какого вида надо создавать для данной платформы, а объект Window просто обращается к ней с запросом о предоставлении какого-нибудь объекта Windowlmp, при этом понятно, что объект получит то, что нужно. Преимущество описанного подхода: класс Abstraction напрямую не привязан ни к одному из классов Imp lament or;
					</li>
					<li>
						<i>а разделение реализаторов.</i>
						Джеймс Коплиен показал, как в C++ можно применить идиому описатель/тело, чтобы несколькими	объектами могла совместно использоваться одна и та же реализация [Сор92]. В теле хранится счетчик ссылок, который увеличивается и уменьшается в классе описателя. Код для присваивания значений описателям, разделяющим одно тело, в общем виде выглядит так:	
						<pre>
							Handles Handle::operator= (const Handles other) {
						  &nbsp;&nbsp;other._body->Ref();
						  &nbsp;&nbsp;_body->Unref();
						
						  &nbsp;&nbsp;if (_body->RefCount() == 0) {
						  &nbsp;&nbsp;delete _body;
						  &nbsp;&nbsp;_body = other._body;
						
						  &nbsp;&nbsp;return*this; 
						  &nbsp;&nbsp;classWindow {
						  &nbsp;&nbsp;publc:
							&nbsp;&nbsp;Window(View* contents);
							
							&nbsp;&nbsp;// запросы, обрабатываемые окном
							&nbsp;&nbsp;virtual void DrawContents();
							
							&nbsp;&nbsp;virtual void Open();
							&nbsp;&nbsp;virtual void Close();
							&nbsp;&nbsp;virtual void IconifyO,-
							&nbsp;&nbsp;virtual void Deiconify();
							
							&nbsp;&nbsp;// запросы, перенаправляемые реализации
							&nbsp;&nbsp;virtual void SetOrigin(const Point& at);
							&nbsp;&nbsp;virtual void SetExtent(const Point& extent);
							&nbsp;&nbsp;virtual void Raise();
							&nbsp;&nbsp;virtual void Lower();
							
							&nbsp;&nbsp;virtual void DrawLine(const Points, const Point&);
							&nbsp;&nbsp;virtual void DrawRect(const Point&, const Point&);
							&nbsp;&nbsp;virtual void DrawPolygon(const Point[], int n);
							&nbsp;&nbsp;virtual void DrawText(const char*, const Point&);
						
					 		&nbsp;&nbsp;protected:
						  &nbsp;&nbsp;Windowlmp* GetWindowImp();
							&nbsp;&nbsp;View* GetViewO ;
						
						  &nbsp;&nbsp;private:
							&nbsp;&nbsp;Windowlmp* _imp;
							&nbsp;&nbsp;View* _contents; // содержимое окна
						  };
						</pre>
					</li>	 
					<li>
						<i>только один класс Implementor.</i>
						В ситуациях, когда есть только одна реализация, создавать абстрактный класс Implementor	необязательно. Это вырожденный случай паттерна мост- между классами Abstraction и Implementor существует взаимно-однозначное соответствие.Тем не менее разделение все же полезно, если нужно, чтобы изменение реализации класса	не отражалось на существующих клиентах (должно быть достаточно заново скомпоновать программу, не перекомпилируя 	клиентский код). Для описания такого разделения Каролан (Carolan) [Car89] употребляет сочетание «чеширский кот».	В C++ интерфейс класса Implementor можно определить в закрытом заголовочном файле, который не передается клиентам.	Это позволяет полностью скрыть реализацию класса от клиентов; 
					</li>
					<li>
						<i>создание правильного объекта Implementor.</i>
						Как, когда и где принимается решение о том, какой из нескольких классов  Implementor инстанцировать? Если у класса Abstraction есть информация о конкретных классах Concretelmplementor, то онможет инстанцировать один из них в своем конструкторе; какой именно - зависит от переданных конструктору параметров.	Так, если класс коллекции поддерживает несколько реализаций, то решение можно принять в зависимости от размера коллекции.	Для небольших коллекций применяется реализация в виде связанного списка, для больших - в виде хэшированных таблиц.  Другой подход - заранее выбрать реализацию по умолчанию, а позже изменять ее в соответствии с тем, как она используется.	Например, если число элементов в коллекции становится больше некоторой условной величины, то мы переключаемся	с одной реализации на другую, более эффективную.Можно также делегировать решение другому объекту.В примере с иерархиями	Window/Windowlmp уместно было бы ввести фабричный объект (см. паттерн абстрактная фабрика), единственная задача 	которого - инкапсулировать платформенную специфику. Фабрика обладает информацией, объекты Windowlmp какого вида	надо создавать для данной платформы, а объект Window просто обращается к ней с запросом о предоставлении какого-нибудь	объекта Windowlmp, при этом понятно, что объект получит то, что нужно. Преимущество описанного подхода:класс Abstraction напрямую не привязан ни к одному из классов Imp lament or;
					</li>
					<li>
						<i>а разделение реализаторов.</i>
						Джеймс Коплиен показал, как в C++ можно применить идиому описатель/тело, чтобы несколькими объектами могла совместно использоваться одна и та же реализация [Сор92]. В теле хранится счетчик ссылок, который увеличивается и уменьшается в классе описателя. Код для присваивания значений описателям, разделяющим одно тело,  в общем виде выглядит так:
						<pre>
							Handles Handle::operator= (const Handles other) {
							&nbsp;&nbsp;other._body->Ref();
							&nbsp;&nbsp;_body->Unref();
					
							&nbsp;&nbsp;if (_body->RefCount() == 0) {
							&nbsp;&nbsp;delete _body;
							&nbsp;&nbsp;body = other._body;
				
							&nbsp;&nbsp;return *this; 
							&nbsp;&nbsp;class Window {
							&nbsp;&nbsp;public:
							&nbsp;&nbsp;Window(View* contents);
					
							&nbsp;&nbsp;// запросы, обрабатываемые окном
							&nbsp;&nbsp;virtual void DrawContents();
					
							&nbsp;&nbsp;virtual void Open();
							&nbsp;&nbsp;virtual void Close();
							&nbsp;&nbsp;virtual void IconifyO,-
							&nbsp;&nbsp;virtual void Deiconify();
					
							&nbsp;&nbsp;// запросы, перенаправляемые реализации
							&nbsp;&nbsp;virtual void SetOrigin(const Point& at);
							&nbsp;&nbsp;virtual void SetExtent(const Point& extent);
							&nbsp;&nbsp;virtual void Raise();
							&nbsp;&nbsp;virtual void Lower();
					
							&nbsp;&nbsp;Virtual void DrawLine(const Points, const Point&);
							&nbsp;&nbsp;virtual void DrawRect(const Point&, const Point&);
							&nbsp;&nbsp;virtual void DrawPolygon(const Point[], int n);
							&nbsp;&nbsp;virtual void DrawText(const char*, const Point&);
					
							&nbsp;&nbsp;protected:
							&nbsp;&nbsp;Windowlmp* GetWindowImp();
							&nbsp;&nbsp;View* GetViewO ;
					
							&nbsp;&nbsp;private:
							&nbsp;&nbsp;Windowlmp* _imp;
							&nbsp;&nbsp;View* _contents; // содержимое окна
							};
						</pre>
						<p>В классе Window хранится ссылка на Windowlmp - абстрактный класс, в котором объявлен интерфейс к данной оконной системе:</p>
						<pre>
							class Windowlmp {
							&nbsp;&nbsp;public:
							&nbsp;&nbsp;virtual void ImpTopO = 0;
							&nbsp;&nbsp;virtual void ImpBottomO = 0;
							&nbsp;&nbsp;virtual void ImpSetExtent(const Point&) = 0;
							&nbsp;&nbsp;virtual void ImpSetOrigin(const Points) = 0;
					
							&nbsp;&nbsp;virtual void DeviceRect(Coord, Coord, Coord, Coord) = 0;
							&nbsp;&nbsp;virtual void DeviceText(const char*, Coord, Coord) = 0;
							&nbsp;&nbsp;virtual void DeviceBitmap(const char*, Coord, Coord) = 0;
							&nbsp;&nbsp;// множество других функций для рисования в окне...
							&nbsp;&nbsp;protected:
							&nbsp;&nbsp;Windowlmp();
							};
						</pre>
						<p>Подклассы Window определяют различные виды окон, как то: окно приложения,пиктограмма, временное диалоговое окно, плавающая палитра инструментов и т.д.</p>
					</li>
				</ul>
				<p>Например, класс ApplicationWindow реализует операцию DrawContents для отрисовки содержимого экземпляра класса View, который в нем хранится:</p>
				<pre>
					// ...
					&nbsp;&nbsp;virtual void DrawContents();
					};
					void ApplicationWindow::DrawContents () {
					&nbsp;&nbsp;GetViewO ->DrawOn(this) ;
					}
				</pre>
				<p>А в классе IconWindow содержится имя растрового изображения для пиктограммы</p>
				<pre>
			    class IconWindow : public Window {
				  &nbsp;&nbsp;public:
				  &nbsp;&nbsp;// ...
				  &nbsp;&nbsp;virtual void DrawContents();
				  private:
				  &nbsp;&nbsp;const char* _bitmapName;
				  };
				</pre>
				<p>и реализация операции DrawContents для рисования этого изображения в окне:</p>
				<pre>
					void IconWindow::DrawContents() {
					&nbsp;&nbsp;Windowlmp* imp = GetWindowImp();
					&nbsp;&nbsp;if (imp != 0) {
					&nbsp;&nbsp;imp->DeviceBitmap(_bitmapName, 0.0, 0.0);
					&nbsp;&nbsp;}
					}
				</pre>
				<p>Могут существовать и другие разновидности класса Window. Окну класса TransientWindow иногда необходимо как-то сообщаться с создавшим его окном во время диалога, поэтому в объекте класса хранится ссылка на создателя. Окно класса PaletteWindow всегда располагается поверх других. Окно класса ZconDockWindow (контейнер пиктограмм) хранит окна класса IconWindow и располагает их в ряд.	Подклассы Window определяют различные виды окон, как то: окно приложения,пиктограмма, временное диалоговое окно, плавающая палитра инструментов и т.д.</p>
				<p>Например, класс ApplicationWindow реализует операцию DrawContents для отрисовки содержимого экземпляра класса View, который в нем хранится:</p>
				<pre>   
				 	// ...
					&nbsp;&nbsp;virtual void DrawContents();
					};
					&nbsp;&nbsp;void ApplicationWindow::DrawContents () {
					&nbsp;&nbsp;GetViewO ->DrawOn(this) ;
					}
				</pre>
				<p>А в классе IconWindow содержится имя растрового изображения для пиктограммы</p>
				<pre> 
				  class IconWindow : public Window {
					&nbsp;&nbsp;public:
					&nbsp;&nbsp;// ...
					&nbsp;&nbsp;virtual void DrawContents();
					&nbsp;&nbsp;private:
					&nbsp;&nbsp;const char* _bitmapName;
					};
				</pre>
				<p>и реализация операции DrawContents для рисования этого изображения в окне:</p>
				<pre>
				  void IconWindow::DrawContents() {
					&nbsp;&nbsp;Windowlmp* imp = GetWindowImp();
					&nbsp;&nbsp;if (imp != 0) {
					&nbsp;&nbsp;imp->DeviceBitmap(_bitmapName, 0.0, 0.0);
					&nbsp;&nbsp;}
					}
				</pre>
				<p>Могут существовать и другие разновидности класса Window. Окну класса TransientWindow иногда необходимо как-то сообщаться с создавшим его окном во время диалога, поэтому в объекте класса хранится ссылка на создателя. Окно класса PaletteWindow всегда располагается поверх других. Окно класса ZconDockWindow (контейнер пиктограмм) хранит окна класса IconWindow и располагает их в ряд.</p>
				<p>Операции класса Window определены в терминах интерфейса Windowlmp.Например, DrawRect вычисляет координаты по двум своим параметрам Point перед тем, как вызвать операцию Windowlmp, которая рисует в окне прямоугольник:</p>
				<pre>
				  void Window: : DrawRect (const Point& pi, const Points p2) {
					&nbsp;&nbsp;Windowlmp* imp = GetWindowImp ( ) ;
					&nbsp;&nbsp;imp->DeviceRect(pl.X() , pl.YO, p2.X(), p2.Y());
					}
				</pre>
				<p>Конкретные подклассы Windowlmp поддерживают разные оконные системы.ак, класс XWindowImp ориентирован на систему X Window:</p>	
				<pre>
				  class XWindowImp : public Windowlmp {
					&nbsp;&nbsp;public:
					&nbsp;&nbsp;XWindowImp();
					&nbsp;&nbsp;virtual void DeviceRect(Coord, Coord, Coord, Coord);
					&nbsp;&nbsp;// прочие операции открытого интерфейса...

					private:
					&nbsp;&nbsp;// переменные, описывающие специфичное для X Window состояние,
					&nbsp;&nbsp;// в том числе:
					&nbsp;&nbsp;Display* _dpy;
					&nbsp;&nbsp;Drawable _winid; // идентификатор окна
					&nbsp;&nbsp;GC _gc; // графический контекст окна
					};

					Для Presentation Manager (РМ) мы определяем класс PMWindowImp:
					class PMWindowImp : public Windowlmp {
					&nbsp;&nbsp;public:
					&nbsp;&nbsp;PMWindowImp () ;
					&nbsp;&nbsp;virtual void DeviceRect(Coord, Coord, Coord, Coord);
					&nbsp;&nbsp;// прочие операции открытого интерфейса...
					private:
					&nbsp;&nbsp;// переменные, описывающие специфичное для РМ Window состояние,
					&nbsp;&nbsp;// в том числе:
					&nbsp;&nbsp;HPS _hps;
					};
				</pre>
				<p>
					<b>Эти подклассы реализуют операции Windowlmp в терминах примитивов оконной системы. Например, DeviceRect для X Window реализуется так:</b>
				</p>
				<pre>
				  void XWindowImp::DeviceRect (
					&nbsp;&nbsp;Coord xO, Coord yO, Coord xl, Coord yl
					) {
					&nbsp;&nbsp;int x = round(min(xO, xl));
					&nbsp;&nbsp;int у = rpund(min(yO, yl));
					&nbsp;&nbsp;int w = round(abs(xO - xl)};
					&nbsp;&nbsp;int h = round(abs(yO - yl));
					&nbsp;&nbsp;XDrawRectangle(_dpy, _winid, _gc, x, y, w, h);
					}
					
					А для РМ - так:
					void PMWindowImp::DeviceRect (
					&nbsp;&nbsp;Coord xO, Coord yO, Coord xl, Coord yl
					) {
					&nbsp;&nbsp;Coord left = min(xO, xl) ;
					&nbsp;&nbsp;Coord right = max(xO, xl);
					&nbsp;&nbsp;Coord bottom = min(yO, yl) ;
					&nbsp;&nbsp;Coord top = max(yO, yl);
					&nbsp;&nbsp;PPOINTL point[4]; Паттерн Bridge
					&nbsp;&nbsp;point[0].x = left; point[0].у = top;
					&nbsp;&nbsp;point[1].x = right; point[1].у = top;
					&nbsp;&nbsp;point[2].x = right; point[2].у = bottom;
					&nbsp;&nbsp;point[3].x = left; point[3].у = bottom;
					&nbsp;&nbsp;if (
					&nbsp;&nbsp;(GpiBeginPath(_hps, 1L) == false) I I
					&nbsp;&nbsp;(GpiSetCurrentPosition(_hps, &point[3]) == false) II
					&nbsp;&nbsp;(GpiPolyLine(_hps, 4L, point) == GPI_ERROR) II
					&nbsp;&nbsp;(GpiEndPath(_hps) == false)
					) {
					// сообщить об ошибке
					} else {
					&nbsp;&nbsp;GpiStrokePath(_hps, 1L, OL);
					&nbsp;&nbsp;}
					}
				</pre>
				<p>Как окно получает экземпляр нужного подкласса Windowlmp? В данном примере мы предположим, что за это отвечает класс Window.  Его операция GetWindowImp получает подходящий экземпляр от абстрактной фабрики (см. описание паттерна абстрактная фабрика), которая инкапсулирует все зависимости от оконной системы.</p>
				<pre>
					Windowlmp* Window: : GetWindowImp () {
			   	&nbsp;&nbsp;if (_imp == 0) {
				 	&nbsp;&nbsp;_imp = WindowSystemFactory :: Instance () ->MakeWindowImp( );
			   	}
			   	return _imp;
				</pre>
				<p>WindowSystemFactory : : Instance ( ) возвращает абстрактную фабрику, которая изготавливает все системно-зависимые объекты.	Для простоты мы сделали эту фабрику одиночкой и позволили классу Window обращаться к ней напрямую.</p>
				<h3>Известные применения</h3>
				<p>Пример класса Window позаимствован из ЕТ++ [WGM88]. В ЕТ++ класс Windowlmp называется WindowPort и имеет такие подклассы,	как XWindowPort и SunWindowPort. Объект Window создает соответствующего себе реализатора Implementor, запрашивая его у абстрактной фабрики, которая называется WindowSystem. Эта фабрика предоставляет интерфейс для создания платформенно-зависимых объектов: шрифтов, курсоров, растровых изображений и т.д.</p>
				<p>Дизайн классов Window/WindowPort в ЕТ++ обобщает паттерн мост в том отношении, что WindowPort сохраняет также обратную     ссылку на Window. Класс-реализатор WindowPort использует эту ссылку для извещения Window о событиях, специфичных для WindowPort:поступлений событий ввода, изменениях размера окна и т.д.</p>
				<p>В работах Джеймса Коплиена [Сор92] и Бьерна Страуструпа [Str91] упоминаются классы описателей и приводятся некоторые примеры.	Основной акцент Структурные паттерны в этих примерах сделан на вопросах управления памятью, например разделении представления строк и поддержке объектов переменного размера. Нас же в первую очередь интересует поддержка независимых расширений абстракции и ее реализации.</p>
				<p>В библиотеке libg++ [Lea88] определены классы, которые реализуют универсальные структуры данных: Set (множество), LinkedSet (множество как связанный список), HashSet (множество какхэш-таблица), LihkedList (связанный список) и HashTable (хэш-таблица). Set - это абстрактный класс, определяющий абстракцию множества, a LinkedList и HashTable - конкретные реализации связанного списка и хэш-таблицы. LinkedSet и HashSet - реализаторы абстракции Set, перекидывающие мост между Set и LinkedList и HashTable соответственно. Перед вами пример вырожденного моста, поскольку абстрактного класса Implement or здесь нет.</p>
				<p>В библиотеке NeXT AppKit [Add94] паттерн мост используется при реализации и отображении графических изображений. Рисунок может быть представлен  по-разному. Оптимальный способ его отображения на экране зависит от свойств дисплея и прежде всего от числа цветов и разрешения. Если бы не AppKit, то для каждого приложения разработчикам пришлось бы самостоятельно выяснять, какой реализацией пользоваться в конкретных условиях</p>
				<p>AppKit предоставляет мост NXImage/NXImageRep. Класс NXImage определяет интерфейс для обработки изображений. Реализация же определена в отдельной иерархии классов NXImageRep, в которой есть такие подклассы,как NXEPSImageRep, NXCachedlmageRep и NXBitMapImageRep. В классе NXImage хранятся ссылки на один или более объектов NXImageRep. Если имеется более одной реализации изображения, то NXImage выбирает самую подходящую для данного дисплея. При необходимости NXImage также может преобразовать изображение из одного формата в другой. Интересная особенность этого варианта моста в том, что NXImage может одновременно хранить несколько реализаций NXImageRep.</p>
				<pre>
				  void Window: : DrawRect (const Point& pi, const Points p2) {
					&nbsp;&nbsp;Windowlmp* imp = GetWindowImp ( ) ;
					&nbsp;&nbsp;imp->DeviceRect(pl.X() , pl.YO, p2.X(), p2.Y());
					}
				</pre>
				<p>Конкретные подклассы Windowlmp поддерживают разные оконные системы.ак, класс XWindowImp ориентирован на систему X Window:</p>
				<pre>
				  class XWindowImp : public Windowlmp {
					&nbsp;&nbsp;public:
					&nbsp;&nbsp;XWindowImp();
					&nbsp;&nbsp;virtual void DeviceRect(Coord, Coord, Coord, Coord);
					&nbsp;&nbsp;// прочие операции открытого интерфейса...
					&nbsp;&nbsp;private:
					&nbsp;&nbsp;// переменные, описывающие специфичное для X Window состояние,
					&nbsp;&nbsp;// в том числе:
					&nbsp;&nbsp;Display* _dpy;
					&nbsp;&nbsp;Drawable _winid; // идентификатор окна
					&nbsp;&nbsp;GC _gc; // графический контекст окна
					};
					&nbsp;&nbsp;Для Presentation Manager (РМ) мы определяем класс PMWindowImp:
					&nbsp;&nbsp;class PMWindowImp : public Windowlmp {
					&nbsp;&nbsp;public:
					&nbsp;&nbsp;PMWindowImp () ;
					&nbsp;&nbsp;;virtual void DeviceRect(Coord, Coord, Coord, Coord);
					&nbsp;&nbsp;// прочие операции открытого интерфейса...
					&nbsp;&nbsp;private:
					&nbsp;&nbsp;// переменные, описывающие специфичное для РМ Window состояние,
					&nbsp;&nbsp;// в том числе:
					&nbsp;&nbsp;HPS _hps;
					};
				</pre>
				<p>
					<b>Эти подклассы реализуют операции Windowlmp в терминах примитивовоконной системы. Например, DeviceRect для X Window реализуется так:</b>
				</p>
				<pre>
				  void XWindowImp::DeviceRect (
					&nbsp;&nbsp;Coord xO, Coord yO, Coord xl, Coord yl
					) {
					&nbsp;&nbsp;int x = round(min(xO, xl));
					&nbsp;&nbsp;int у = rpund(min(yO, yl));
					&nbsp;&nbsp;int w = round(abs(xO - xl)};
					&nbsp;&nbsp;int h = round(abs(yO - yl));
					&nbsp;&nbsp;XDrawRectangle(_dpy, _winid, _gc, x, y, w, h);
					}

					А для РМ - так:
					void PMWindowImp::DeviceRect (
					&nbsp;&nbsp;Coord xO, Coord yO, Coord xl, Coord yl
					) {
					&nbsp;&nbsp;Coord left = min(xO, xl) ;
					&nbsp;&nbsp;Coord right = max(xO, xl);
					&nbsp;&nbsp;Coord bottom = min(yO, yl) ;
					&nbsp;&nbsp;Coord top = max(yO, yl);
					&nbsp;&nbsp;PPOINTL point[4]; Паттерн Bridge
					&nbsp;&nbsp;point[0].x = left; point[0].у = top;
					&nbsp;&nbsp;point[1].x = right; point[1].у = top;
					&nbsp;&nbsp;point[2].x = right; point[2].у = bottom;
					&nbsp;&nbsp;point[3].x = left; point[3].у = bottom;
					&nbsp;&nbsp;if (
					&nbsp;&nbsp;(GpiBeginPath(_hps, 1L) == false) I I
					&nbsp;&nbsp;(GpiSetCurrentPosition(_hps, &point[3]) == false) II
					&nbsp;&nbsp;(GpiPolyLine(_hps, 4L, point) == GPI_ERROR) II
					&nbsp;&nbsp;(GpiEndPath(_hps) == false)
					) {
					// сообщить об ошибке
					} else {
					&nbsp;&nbsp;GpiStrokePath(_hps, 1L, OL);
					&nbsp;&nbsp;}
					}
				</pre>
				<p>Как окно получает экземпляр нужного подкласса Windowlmp? В данном примере мы предположим, что за это отвечает класс Window. Его операция GetWindowImp получает подходящий экземпляр от абстрактной фабрики (см. описание паттерна абстрактная фабрика), которая инкапсулирует все зависимости от оконной системы.</p>
				<pre>
			    Windowlmp* Window: : GetWindowImp () {
					&nbsp;&nbsp;if (_imp == 0) {
					&nbsp;&nbsp;_imp = WindowSystemFactory :: Instance () ->MakeWindowImp( );
				  }
				  return _imp;
				</pre>
				<p>WindowSystemFactory : : Instance ( ) возвращает абстрактную фабрику, которая изготавливает все системно-зависимые объекты. Для простоты мы сделали эту фабрику одиночкой и позволили классу Window обращаться к ней напрямую.</p>
				<h3>Известные применения</h3>
				<p>Пример класса Window позаимствован из ЕТ++ [WGM88]. В ЕТ++ класс Windowlmp называется WindowPort и имеет такие подклассы,	как XWindowPort и SunWindowPort. Объект Window создает соответствующего себе реализатора Implementor, 	запрашивая его у абстрактной фабрики, которая называется WindowSystem. Эта фабрика предоставляет интерфейс для 	создания платформенно-зависимых объектов: шрифтов, курсоров, растровых изображений и т.д.</p>
				<p>Дизайн классов Window/WindowPort в ЕТ++ обобщает паттерн мост в том отношении, что WindowPort сохраняет также обратную     ссылку на Window. Класс-реализатор WindowPort использует эту ссылку для извещения Window о событиях, специфичных для WindowPort:поступлений событий ввода, изменениях размера окна и т.д.</p>
				<p>В работах Джеймса Коплиена [Сор92] и Бьерна Страуструпа [Str91] упоминаются классы описателей и приводятся некоторые примеры. Основной акцент Структурные паттерны в этих примерах сделан на вопросах управления памятью, например разделении представления строк и поддержке объектов переменного размера. Нас же в первую очередь интересует поддержка независимых расширений абстракции и ее реализации.</p>
				<p>В библиотеке libg++ [Lea88] определены классы, которые реализуют универсальные структуры данных: Set (множество), LinkedSet (множество как связанный список), HashSet (множество какхэш-таблица), LihkedList (связанный  список) и HashTable (хэш-таблица). Set - это абстрактный класс, определяющий абстракцию множества, a LinkedList и HashTable - конкретные реализации связанного списка и хэш-таблицы. LinkedSet и HashSet - реализаторы абстракции Set, перекидывающие мост между Set и LinkedList и HashTable соответственно. Перед вами пример вырожденного моста, поскольку абстрактного класса Implement or здесь нет.</p>
				<p>В библиотеке NeXT AppKit [Add94] паттерн мост используется при реализации и отображении графических изображений.	Рисунок может быть представлен  по-разному. Оптимальный способ его отображения на экране зависит от свойств	дисплея и прежде всего от числа цветов и разрешения. Если бы не AppKit, то для каждого приложения разработчикам пришлось	бы самостоятельно выяснять, какой реализацией пользоваться в конкретных условиях</p>
				<p>AppKit предоставляет мост NXImage/NXImageRep. Класс NXImage определяет интерфейс для обработки изображений. Реализация же определена в отдельной иерархии классов NXImageRep, в которой есть такие подклассы,как NXEPSImageRep, NXCachedlmageRep и NXBitMapImageRep. В классе NXImage хранятся ссылки на один или более объектов NXImageRep. Если имеется более одной реализации изображения, то NXImage выбирает самую подходящую для данного дисплея. При необходимости NXImage также может преобразовать изображение из одного формата в другой. Интересная особенность этого варианта моста в том, что NXImage может одновременно хранить несколько реализаций NXImageRep.</p>
			</div>
		</section>
	</main>
	<footer>
		<a href="index.html" class="go-home-button">&nbsp;</a>
		<a href="#promo" class="go-top">&nbsp;</a>
		<div class="container">
			<p>&#169; Copyright 2016 &nbsp; <a href="#">#HardhatsTeam</a></p>
		</div>
	</footer>
</body>
</html>