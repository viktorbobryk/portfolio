<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta name="description" content="Object-Oriented Software" />
	<meta name="keywords" content="Design, Patterns, Elements, Reusable, Object-Oriented, Software" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Flyweight Page</title>
	<link rel="stylesheet" href="css/reset.css" />
	<link rel="stylesheet" href="css/style.css" />
</head>
<body>
	<span class="layout-indicator"></span>
	<header class="header-menu">
		<div class="top-wrap">
			<div class="container">
				<nav>
					<ul>
						<li><a href="adapter.html">Паттерн Adapter</a></li>
						<li><a href="bridge.html">Паттерн Bridge</a></li>
						<li><a href="composite.html">Паттерн Composite</a></li>
						<li><a href="decorator.html">Паттерн Decorator</a></li> 
						<li><a href="facade.html">Паттерн Facade</a></li>
						<li><a href="flyweight.html" class="active">Паттерн Flyweight</a></li><!-- !!! link MUST have .active class on corresponding page !!! -->
						<li><a href="proxy.html">Паттерн Proxy</a></li>
					</ul>
				</nav>
			</div>
		</div>
		<span class="arrow-down arrow-menu">&nbsp;</span>
	</header>
	<main>
		<section id="promo" class="promo-section flyweight-promo">
		<div class="overlay"></div>
			<div class="container">
				<div class="titles-wrapper">
					<h1>Паттерн Flyweight</h1>
				</div>
			</div>
		</section>		
		<section class="content-section">
			<div class="container">				
				<h3>Название и классификация паттерна</h3>
				<p>Приспособленец - паттерн, структурирующий объекты.</p>
				<h4>Назначение</h4>
				<p>Использует разделение для эффективной поддержки множества мелких объектов.</p>
				<h4>Мотивация</h4>
				<p>В некоторых приложениях использование объектов могло бы быть очень полезным, но прямолинейная реализация оказывается недопустимо расточительной.	Например, в большинстве редакторов документов имеются средства форматирования и редактирования текстов, в той или иной степени модульные. Объектно-ориентированные редакторы обычно применяют объекты для представления	таких встроенных элементов, как таблицы и рисунки. Но они не используют	объекты для представления каждого символа, несмотря на то что это увеличило	бы гибкость на самых нижних уровнях приложения. Ведь тогда к рисованию и форматированию символов и встроенных элементов можно былб бы применить единообразный подход. И для поддержки новых наборов символов не пришлось бы	как-либо затрагивать остальные функции редактора. Да и общая структура приложения отражала бы физическую структуру документа. На следующей диаграмме	показано, как редактор документов мог бы воспользоваться объектами для представления символов.</p>
				<p>У такого дизайна есть один недостаток - стоимость. Даже в документе скромных размеров было бы несколько сотен тысяч объектов-символов, а это привело	бы к расходованию огромного объема памяти и неприемлемым затратам во время	выполнения. Паттерн приспособленец показывает, как разделять очень мелкие	объекты без недопустимо высоких издержек.</p>
				<div class="wrap-image">
				  <img src="img/img-pattern/img1561.jpg" alt="" />
				</div>
				<p>Приспособленец - это разделяемый объект, который можно использовать одновременно в нескольких контекстах. В каждом контексте он выглядит как независимый объект, то есть неотличим от экземпляра, который не разделяется. Приспособленцы не могут делать предположений о контексте, в котором работают. Ключевая идея здесь - различие между внутренним и внешним состояниями. Внутреннее состояние хранится в самом приспособленце и состоит из информации, не зависящей от его контекста. Именно поэтому он может разделяться. Внешнее состояние зависит от контекста и изменяется вместе с ним, поэтому не подлежит разделению. Объекты-клиенты отвечают за передачу внешнего состояния приспособленцу, когда в этом возникает необходимость.</p>
				<p>Приспособленцы моделируют концепции или сущности, число которых слишком велико для представления объектами. Например, редактор документов мог бы создать по одному приспособленцу для каждой буквы алфавита. Каждый приспособленец хранит код символа, но координаты положения символа в документе и стиль его начертания определяются алгоритмами размещения текста и командами форматирования, действующими в том месте, где символ появляется. Код символа - это внутреннее состояние, а все остальное - внешнее.</p>
				<p>Логически для каждого вхождения данного символа в документ существует объект.</p>
				<div class="wrap-image">
				  <img src="img/img-pattern/img1572.jpg" alt="" />
				</div>
				<p>Физически, однако, есть лишь по одному объекту-приспособленцу для каждого символа, который появляется в различных контекстах в структуре документа. Каждое вхождение данного объекта-символа ссылается на один и тот же экземпляр в разделяемом пуле объектов-приспособленцев.</p>
				<div class="wrap-image">
				  <img src="img/img-pattern/img1570.jpg" alt="" />
				</div>
				<p>Ниже изображена структура класса для этих объектов. Glyph - это абстрактный класс для представления графических объектов (некоторые из них могут быть приспособленцами). Операции, которые могут зависеть от внешнего состояния, передают его в качестве параметра. Например, операциям Draw (рисование) и Intersects (пересечение) должно быть известно, в каком контексте встречается глиф, иначе они не смогут выполнить то, что от них требуется.</p>
				<div class="wrap-image">
					<img src="img/img-pattern/img1579.jpg" alt="" />
				</div>
				<p class="paragraph-two-column">Приспособленец, представляющий букву «а», содержит только соответствующий ей код; ни положение, ни шрифт буквы ему хранить не надо. Клиенты передают приспособленцу всю зависящую от контекста информацию, которая нужна, чтобы он мог изобразить себя. Например, глифу Row известно, где его потомки должны себя показать, чтобы это выглядело как горизонтальная строка. Поэтому вместе с запросом на рисование он может передавать каждому потомку координаты. Поскольку число различных объектов-символов гораздо меньше, чем число символов в документе, то и общее количество объектов существенно меньше, чем было бы при простой реализации. Документ, в котором все символы изображаются одним шрифтом и цветом, создаст порядка 100 объектов-символов (это примерно равно числу кодов в таблице ASCII) независимо от своего размера. А поскольку в большинстве документов применяется не более десятка различных комбинаций шрифта и цвета, то на практике эта величина возрастет несущественно. Поэтому абстракция объекта становится применимой и к отдельным символам.</p>
				<h4>Применимость</h4>
				<p>Эффективность паттерна приспособленец во многом зависит от того, как
				и где он используется. Применяйте этот паттерн, когда выполнены все нижеперечисленные условия:</p>
				<ul>
					<li>а в приложении используется большое число объектов;</li>
					<li>а из-за этого накладные расходы на хранение высоки;</li>
					<li>а большую часть состояния объектов можно вынести вовне;</li>
					<li>а многие группы объектов можно заменить относительно небольшим количеством разделяемых объектов, поскольку внешнее состояние вынесено;</li>
					<li>а приложение не зависит от идентичности объекта. Поскольку объекты-приспособленцы могут разделяться, то проверка на идентичность возвратит «истину» для концептуально различных объектов.</li>
				</ul>
				<h4>Структура</h4>
				<div class="wrap-image">
				  <img src="img/img-pattern/img1586.jpg" alt="" />
				</div>
				<p>На следующей диаграмме показано, как приспособленцы разделяются.</p>
				<div class="wrap-image">
				  <img src="img/img-pattern/img1584.jpg" alt="" />
				</div>
				<h4>Участники</h4>
				<ul>
					<li>
						<p>a Flyweight (Glyph) - приспособленец:</p>
						<ul>
							<li>объявляет интерфейс, с помощью которого приспособленцы могут получать внешнее состояние или как-то воздействовать на него;</li>
						</ul>
					</li>
					<li>
						<p>a ConcreteFlyweight (Character) конкретный приспособленец:</p>
						<ul>
							<li>реализует интерфейс класса Flyweight и добавляет при необходимости внутреннее состояние. Объект класса ConcreteFlyweight должен быть разделяемым. Любое сохраняемое им состояние должно быть внутренним, то есть не зависящим от контекста;
							</li>
						</ul>
					</li>
					<li>
						<p>a UnsharedConcreteFlyweight (Row, Column) неразделяемый конкретный приспособленец:</p>
						<ul>
							<li>не все подклассы Flyweight обязательно должны быть разделяемыми. Интерфейс Flyweight допускает разделение, но не навязывает его. Часто у объектов UnsharedConcreteFlyweight на некотором уровне структуры приспособленца есть потомки в виде объектов класса Concret eFlyweight, как, например, у объектов классов Row и Column;</li>
						</ul>
					</li>
					<li>
						<p>a FlyweightFactory - фабрика приспособленцев:</p>
						<ul>
							<li>создает объекты-приспособленцы и управляет ими;</li>
							<li>обеспечивает должное разделение приспособленцев. Когда клиент запрашивает приспособленца, объект FlyweightFactory предоставляет существующий экземпляр или создает новый, если готового еще нет;</li>
						</ul>
					</li>
					<li>
						<p>a Client - клиент:</p>
						<ul>
							<li>- хранит ссылки на одного или нескольких приспособленцев;</li>
							<li>- вычисляет или хранит внешнее состояние приспособленцев.</li>
						</ul>
					</li>
				</ul>
				<h4>Отношения</h4>
				<ul>
					<li>а состояние, необходимое приспособленцу для нормальной работы, можноохарактеризовать как внутреннее или внешнее. Первое хранится в самомобъекте ConcreteFlyweight. Внешнее состояние хранится или вычисляется клиентами. Клиент передает его приспособленцу при вызове операций;</li>
					<li>а клиенты не должны создавать экземпляры класса ConcreteFlyweightнапрямую, а могут получать их только от объекта FlyweightFactory. Этопозволит гарантировать корректное разделение.</li>
				</ul>
				<h4>Результаты</h4>
				<p>При использовании приспособленцев не исключены затраты на передачу, поиск или вычисление внутреннего состояния, особенно если раньше оно хранилось	как внутреннее. Однако такие расходы с лихвой компенсируются экономией памяти за счет разделения объектов-приспособленцев.</p>
				<p>Экономия памяти возникает по ряду причин:</p>
				<ul>
					<li>а уменьшение общего числа экземпляров;</li>
					<li>а сокращение объема памяти, необходимого для хранения внутреннего состояния;</li>
					<li>а вычисление, а не хранение внешнего состояния (если это действительно так).</li>
				</ul>
				<p>Чем выше степень разделения приспособленцев, тем существеннее экономия. С увеличением объема разделяемого состояния экономия также возрастает. Самого большого эффекта удается добиться, когда суммарный объем внутренней и внешней информации о состоянии велик, а внешнее состояние вычисляется, а не хранится. Тогда разделение уменьшает стоимость хранения внутреннего состояния, а за счет вычислений сокращается память, отводимая под внешнее состояние.</p>
				<p>Паттерн приспособленец часто применяется вместе с компоновщиком для представления иерархической структуры в виде графа с разделяемыми листовыми узлами. Из-за разделения указатель на родителя не может храниться в листовом узле-приспособленце, а должен передаваться ему как часть внешнего состояния. Это оказывает заметное влияние на способ взаимодействия объектов иерархии между собой.</p>
				<h4>Реализация</h4>
				<p>При реализации приспособленца следует обратить внимание на следующие	вопросы:</p>
				<ul>
					<li>а вынесение внешнего состояния. Применимость паттерна в значительной степени зависит от того, насколько легко идентифицировать внешнее состояние и вынести его за пределы разделяемых объектов. Вынесение внешнего
					состояния не уменьшает стоимости хранения, если различных внешних состояний так же много, как и объектов до разделения. Лучший вариант внешнее состояние вычисляется по объектам с другой структурой, требующей значительно меньшей памяти.	Например, в нашем редакторе документов мы можем поместить карту с типографской информацией в отдельную структуру, а не хранить шрифт и начертание вместе с каждым символом. Данная карта будет отслеживать непрерывные серии символов с одинаковыми типографскими атрибутами.	Когда объект-символ изображает себя, он получает типографские атрибуты	от алгоритма обхода. Поскольку обычно в документах используется немного разных шрифтов и начертаний, то хранить эту информацию отдельно от	объекта-символа гораздо эффективнее, чем непосредственно в нем;</li>
					<li>а управление разделяемыми объектами. Так как объекты разделяются, клиенты не должны инстанцировать их напрямую. Фабрика FlyweightFactory позволяет клиентам найти подходящего приспособленца. В объектах этого класса часто есть хранилище, организованное в виде ассоциативного массива, с помощью которого можно быстро находить приспособленца, нужного клиенту. Так, в примере редактора документов фабрика приспособленцев может содержать внутри себя таблицу, индексированную кодом символа, и возвращать нужного приспособленца по его коду. А если требуемый приспособленец отсутствует, он тут же создается. Разделяемость подразумевает также, что имеется некоторая форма подсчета ссылок или сбора мусора для освобождения занимаемой приспособленцем памяти, когда необходимость в нем отпадает. Однако ни то, ни другое необязательно, если число приспособленцев фиксировано и невелико (например, если речь идет о представлении набора символов кода ASCII). В таком случае имеет смысл хранить приспособленцев постоянно.</li>
				</ul>
				<h4>Пример кода</h4>
				<p>Возвращаясь к примеру с редактором документов, определим базовый класс Glyph для графических объектов-приспособленцев. Логически глифы - это составные объекты, которые обладают графическими атрибутами и умеют изображать себя (см. описание паттерна компоновщик). Сейчас мы ограничимся только шрифтом, но тот же подход применим и к любым другим графическим атрибутам:</p>
				<pre>
					class Glyph {
					&nbsp;&nbsp;public:
					&nbsp;&nbsp;virtual ~Glyph();
					&nbsp;&nbsp;virtual void Draw(Window*, GlyphContext&);
					&nbsp;&nbsp;virtual void SetFont(Font*, GlyphContextk);
					&nbsp;&nbsp;virtual Font* GetFont(GlyphContextk);
					&nbsp;&nbsp;virtual void First(GlyphContext&);
					&nbsp;&nbsp;virtual void Next(GlyphContext&);
					&nbsp;&nbsp;virtual bool IsDone(GlyphContext&);
					&nbsp;&nbsp;virtual Glyph* Current(GlyphContextk);
					&nbsp;&nbsp;virtual void Insert(Glyph*, GlyphContextu);
					&nbsp;&nbsp;virtual void Remove(GlyphContext&};
					&nbsp;&nbsp;protected:
					&nbsp;&nbsp;Glyph();
					};

					В подклассе Character хранится просто код символа:
					class Character : public Glyph {
					&nbsp;&nbsp;public:
					&nbsp;&nbsp;Character(char);
					&nbsp;&nbsp;virtual void Draw(Window*, GlyphContext&);
					&nbsp;&nbsp;private:
					&nbsp;&nbsp;char _charcode;
					};
				</pre>
				<p>Чтобы не выделять память для шрифта каждого глифа, будем хранить этот атрибут во внешнем объекте класса GlyphContext. Данный объект поддерживает соответствие между глифом и его шрифтом (а также любыми другими графическими атрибутами) в различных контекстах. Любой операции, у которой должна быть информация о шрифте глифа в данном контексте, в качестве параметра будет передаваться экземпляр GlyphContext. У него операция и может запросить нужные сведения. Контекст определяется положением глифа в структуре. Поэтому операциями обхода и манипулирования потомками обновляется GlyphContext:</p>
				<pre>
					class GlyphContext {
					&nbsp;&nbsp;public:
					&nbsp;&nbsp;GlyphContext();
					&nbsp;&nbsp;virtual -GlyphContext();
					&nbsp;&nbsp;virtual void Next(int step = 1);
					&nbsp;&nbsp;virtual void Insert(int quantity = 1);
					&nbsp;&nbsp;virtual Font* GetFont();
					&nbsp;&nbsp;virtual void SetFont(Font*, int span = 1);
					&nbsp;&nbsp;private:
					&nbsp;&nbsp;int _index;
					&nbsp;&nbsp;BTree* _fonts;
					};
				</pre>
				<p>Объекту GlyphContext должно быть известно о текущем положении в структуре глифов во время ее обхода. Операция GlyphContext: .-Next увеличивает переменную _index по мере обхода структуры. Подклассы класса Glyph, имеющие потомков (например, Row и Column), должны реализовывать операцию Next так, чтобы она вызывала GlyphContext: :Next в каждой точке обхода.</p>
				<p>Операция GlyphContext: :GetFont использует переменную _index в качестве ключа для структуры ВТгее, в которой хранится отображение между глифами и шрифтами. Каждый узел дерева помечен длиной строки, для которой он
				предоставляет информацию о шрифте. Листья дерева указывают на шрифт, а внутренние узлы разбивают строку на подстроки - по одной для каждого потомка. Рассмотрим фрагмент текста, представляющий собой композицию глифов.</p>
				<div class="wrap-image">
				  <img src="img/img-pattern/img1608.jpg" alt="" />
				</div>
				<p>Структура ВТгее, в которой хранится информация о шрифтах, может выглядеть так:</p>
				<div class="wrap-image">
				  <img src="img/img-pattern/img1612.jpg" alt="" />
				</div>
				<p>Внутренние узлы определяют диапазоны индексов глифов. Дерево обновляется в ответ на изменение шрифта, а также при каждом добавлении и удалении глифов из структуры. Например, если предположить, что текущей точке обхода соответствует индекс 102, то следующий код установит шрифт каждого символа в слове «expect» таким же, как у близлежащего текста (то есть times 12 - экземпляр класса Font для шрифта Times Roman размером 12 пунктов):</p>
				<pre>
					GlyphContext gc;
					Font* timesl2 = new Font("Times-Roman-12");
					Font* timesltalic!2 = new Font("Times-Italic-12");
					// ...
					gc.SetFont(times12, 6);
				</pre>
				<p>Новая структура ВТгее выглядит так (изменения выделены болеецветом):</p>
				<div class="wrap-image">
				  <img src="img/img-pattern/img1621.jpg" alt="" />
				</div>
				<p>Добавим перед «expect» слово «don't » (включая пробел после него), написанное шрифтом Times Italic размером 12 пунктов. В предположении, что текущей позиции все еще соответствует индекс 102, следующий код проинформирует объект gc об этом:</p>
				<pre>
					gc.Insert(6) ;
					gc.SetFont(timesltalicl2, 6);
				</pre>
				<p>Теперь структура ВТгее выглядит так:</p>
				<div class="wrap-image">
				  <img src="img/img-pattern/img1619.jpg" alt="" />
				</div>
				<p>При запрашивании шрифта текущего глифа объект GlyphContext спускается вниз по дереву, суммируя индексы, пока не будет найден шрифт для текущего индекса. Поскольку шрифт меняется нечасто, размер дерева мал по сравнению с размером структуры глифов. Это позволяет уменьшить расходы на хранение без заметного увеличения времени поиска.</p>
				<p>И наконец, нам нужна еще фабрика FlyweightFactory, которая создает глифы и обеспечивает их корректное разделение. Класс GlyphFactory создает объекты Character и глифы других видов. Разделению подлежат только объекты Character. Составных глифов гораздо больше, и их существенное состояние (то есть множество потомков) в любом случае является внутренним:</p>
				<pre>
					const int NCHARCODES = 128;
					&nbsp;&nbsp;class GlyphFactory {
					&nbsp;&nbsp;public:
					&nbsp;&nbsp;GlyphFactory ( ) ;
					&nbsp;&nbsp;virtual -GlyphFactory ();
					&nbsp;&nbsp;virtual Character* CreateCharacter (char) ;
					&nbsp;&nbsp;virtual Row* CreateRowO ;
					&nbsp;&nbsp;virtual Column* CreateColumnO ;
					&nbsp;&nbsp;// ...
					&nbsp;&nbsp;private:
					&nbsp;&nbsp;Character* _character [NCHARCODES] ;
					};
				</pre>
				<p>Массив _character содержит указатели на глифы Character, индексированные кодом символа. Конструктор инициализирует этот массив нулями:</p>
				<pre>
					GlyphFactory: : GlyphFactory () {
					&nbsp;&nbsp;for (int i = 0; i = NCHARCODES; ++i) {
					&nbsp;&nbsp;character [i] = 0;
					&nbsp;&nbsp;}
					}
				</pre>
				<p>Операция CreateCharacter ищет символ в массиве и возвращает соответствующий глиф, если он существует. В противном случае CreateCharacter создает глиф, помещает его в массив и затем возвращает:</p>
				<pre>
					Character* GlyphFactory::CreateCharacter (char с) {
					&nbsp;&nbsp;if (!_character[с]) {
					&nbsp;&nbsp;_character[с] = new Character(с);
					&nbsp;&nbsp;}
					&nbsp;&nbsp;return _character[c];
					}
				</pre>
				<p>Остальные операции просто создают новый объект при каждом обращении,так как несимвольные глифы не разделяются:</p>
				<p>Время поиска в этой схеме пропорционально частоте смены шрифта. Наименьшая производительность бывает, когда смена шрифта происходит на каждом символе, но на практике это бывает редко.</p>
				<pre>
					Row* GlyphFactory:rCreateRow () {
					&nbsp;&nbsp;return new Row;
					}
					&nbsp;&nbsp;Column* GlyphFactory::CreateColumn () {
					&nbsp;&nbsp;return new Column;
					}
				</pre>
				<p>Эти операции можно было бы опустить и позволить клиентам инстанцировать неразделяемые глифы напрямую. Но если позже мы решим сделать разделяемыми и их тоже, то придется изменять клиентский код, в котором они создаются.</p>
				<h4>Известные применения</h4>
				<p class="paragraph-three-column">Концепция объектов-приспособленцев впервые была описана и использована как техника проектирования в библиотеке Interviews 3.0 [CL90]. Ее разработчики построили мощный редактор документов Doc, чтобы доказать практическую полезность подобной идеи. В Doc объекты-глифы используются для представления любого символа документа. Редактор строит по одному экземпляру глифа для каждого сочетания символа и стиля (в котором определены все графические атрибуты). Таким образом, внутреннее состояние символа состоит из его кода и информации о стиле (индекс в таблицу стилей).1 Следовательно, внешней оказывается только позиция, -поэтому Doc работает быстро. Документы представляются классом Document, который выполняет функции фабрики FlyweightFactory.<p>
				<p>Измерения показали, что реализованное в Doc разделение символов-приспособленцев весьма эффективно. В типичном случае для документа из 180 тысяч знаков необходимо создать только 480 объектов-символов.</p>
				<p>В каркасе ЕТ++ [WGM88] приспособленцы используются для поддержки независимости от внешнего облика.2 Его стандарт определяет расположение элементов пользовательского интерфейса (полос прокрутки, кнопок, меню и пр., в совокупности именуемых виджетами) и их оформления (тени и т.д.). Виджет делегирует заботу о своем расположении и изображении отдельному объекту Layout. Изменение этого объекта ведет к изменению внешнего облика даже во время выполнения.</p>
				<p>Для каждого класса виджета имеется соответствующий класс Layout (например, ScrollbarLayout, MenubarLayout и т.д.). В данном случае очевидная проблема состоит в том, что удваивается число объектов пользовательского интерфейса, ибо для каждого интерфейсного объекта есть дополнительный объект Layout. Чтобы избавиться от расходов, объекты Layout реализованы в виде приспособленцев. Они прекрасно подходят на эту роль, так как заняты преимущественно определением поведения и им легко передать тот небольшой объем внешней информации о состоянии, который необходим для изображения объекта.</p>
			</div>
		</section>
	</main>
	<footer>
		<a href="index.html" class="go-home-button">&nbsp;</a>
		<a href="#promo" class="go-top">&nbsp;</a>
		<div class="container">
			<p>&#169; Copyright 2016 &nbsp; <a href="#">#HardhatsTeam</a></p>
		</div>
	</footer>	
</body>
</html>